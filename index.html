<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dish & Dash - Cozy Kitchen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg-cozy: #FBF7F3;
            --text-dark: #4a403a;
            --text-light: #7a6c62;
            --primary: #a3b18a;
            --primary-hover: #919d7a;
            --secondary: #e7c8a0;
            --secondary-hover: #d7b58c;
            --accent: #d4a373;
            --danger: #c78080;
            --locked: #a8a29e;
        }

        body {
            font-family: 'Comfortaa', cursive;
            background-color: var(--bg-cozy);
            color: var(--text-dark);
            background-image: url("data:image/svg+xml,%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23d4a373' fill-opacity='0.1'%3E%3Cpath d='M80 80V0h-29.333c1.05 4.333 1.575 8.833 1.575 13.5C52.242 27.667 45.575 39.583 36.417 46.5c-4.583 3.45-9.25 5.175-14 5.175-3.267 0-6.417-.833-9.5-2.5C11.083 47.333 9.417 44.833 7.5 41.5c-2.417-4.167-3.5-8.5-3.5-13C4 21.333 5.333 15.167 8 9.5V0H0v80h80z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            overflow: hidden;
        }

        h1, h2, #message-title, #recipe-name {
             font-family: 'Kalam', cursive;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            border-bottom: 4px solid rgba(0,0,0,0.2);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .btn:active {
            transform: translateY(1px);
            border-bottom-width: 2px;
        }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-dark); }
        .btn-secondary:hover { background-color: var(--secondary-hover); }
        .btn-danger { background-color: var(--danger); color: white; }
        .btn-danger:hover { background-color: #b96f6f; }
        
        #game-ui, #plate-tower-game { perspective: 1500px; }

        /* --- Level Map Redesign --- */
        #level-map-screen {
            background-color: #eaddcf;
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><defs><pattern id="p" width="120" height="120" patternUnits="userSpaceOnUse" transform="rotate(45)"><path id="a" data-color="outline" fill="none" stroke="%23c4b59d" stroke-width="2" d="M0 0l120 120M60 0l60 60-120 120M120 60l-60 60"></path></pattern></defs><rect fill="%23eaddcf" width="100%" height="100%"></rect><rect fill="url(%23p)" width="100%" height="100%"></rect></svg>');
        }
        #level-map-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 2rem;
            padding: 2rem;
            justify-items: center;
        }
        .level-node-button {
            width: 120px;
            height: 150px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Kalam', cursive;
            color: var(--text-dark);
            border: 1px solid #e5e5e5;
        }
        .level-node-button:not(:disabled):hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 15px rgba(0,0,0,0.15);
        }
        .level-node-button.locked {
            background: #d6d3d1;
            filter: grayscale(80%);
            cursor: not-allowed;
        }
        .level-node-button::before { /* Tape effect */
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%) rotate(-3deg);
            width: 60px;
            height: 25px;
            background: var(--secondary);
            opacity: 0.6;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .level-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        .level-number { font-size: 3rem; font-weight: 700; line-height: 1; color: var(--accent); }
        .level-text-label { font-size: 1rem; }
        .lock-icon-map {
            width: 40px;
            height: 40px;
            color: rgba(0,0,0,0.3);
        }

        /* --- Game UI Redesign --- */
        #order-info {
            background: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            background-image: linear-gradient(#f9fafb 1.1rem, #e5e7eb 1.1rem);
            background-size: 100% 2.2rem;
            padding-top: 2rem;
        }
        #order-info::before { /* Notebook holes */
            content: '';
            position: absolute;
            top: 10px;
            left: 1rem;
            right: 1rem;
            height: 10px;
            background-image: radial-gradient(#d6d3d1 2px, transparent 2px);
            background-size: 20px 10px;
            background-repeat: repeat-x;
        }

        .plate-wrapper {
             perspective: 1000px;
             transform-style: preserve-3d;
             display: flex;
             justify-content: center;
             align-items: flex-end; 
             height: 7rem;
             position: relative;
        }

        .plate-area {
            width: calc(4.2rem + 8px); 
            height: calc(4.2rem + 8px);
            background: radial-gradient(circle, #f8f8f8 70%, #e0e0e0 100%);
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 10px 15px rgba(0,0,0,0.1);
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(30deg) rotateZ(314deg);
        }
        
        .lock-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotateZ(45deg) rotateX(-60deg);
            width: 2rem;
            height: 2rem;
            color: rgba(0,0,0,0.35);
            display: none;
        }
        .plate-area.locked .lock-icon {
            display: block;
        }

        .ingredient {
            position: absolute;
            bottom: 0px;
            left: 50%;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom center;
            pointer-events: none;
            user-select: none;
            width: 4.5rem;
            height: 4.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateX(-50%);
            border-radius: 9999px;
            padding: 6px; 
        }
        .ingredient-inner {
            width: 100%;
            height: 100%;
            border-radius: 9999px;
            background: radial-gradient(circle, #ffffff 60%, #f0efeb 100%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.8rem;
        }
        .ingredient.golden .ingredient-inner { 
            filter: drop-shadow(0 0 5px gold); 
        }

        /* --- Modal Redesign --- */
        #message-box > div, #how-to-play-content {
            background-color: var(--bg-cozy);
            border: 5px solid var(--accent);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-radius: 20px;
        }
        
        .stack-counter {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #ef4444;
            color: white;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
            font-size: 0.85rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            font-family: 'Comfortaa', cursive;
        }
    </style>
</head>
<body class="text-stone-800">
    
    <div id="animation-layer" class="fixed inset-0 pointer-events-none z-50"></div>

    <div id="home-screen" class="flex flex-col items-center justify-center text-center h-screen p-4">
        <img src="logo.png" alt="Game Logo" class="w-24 h-24 sm:w-32 sm:h-32 md:w-64 md:h-64 mb-4 rounded-full">
        <p class="text-2xl text-stone-600 my-4">A Cozy Kitchen Puzzle</p>
        <p class="text-xl text-stone-500 max-w-md mb-8">The chef needs your help. Let's sort these ingredients for the daily orders!</p>
        <button id="start-game-button" class="btn btn-primary text-2xl">
            Start Cooking!
        </button>
        <div class="mt-4 flex gap-4">
            <button id="how-to-play-button" class="btn btn-secondary text-sm">
                How to Play
            </button>
            <button id="reset-progress-button" class="btn btn-danger text-sm">
                Reset Progress
            </button>
       </div>
    </div>
    
    <div id="level-map-screen" class="w-full h-screen mx-auto hidden flex flex-col relative overflow-hidden">
        <div class="flex-shrink-0 text-center z-10 p-6">
            <h2 class="text-5xl md:text-6xl text-amber-900" style="text-shadow: 2px 2px 0px #FBF7F3;">Select a Recipe</h2>
        </div>
        <div class="flex-grow overflow-y-auto z-10">
             <div id="level-map-container">
                <!-- Levels generated by JS -->
             </div>
        </div>
         <div class="text-center flex-shrink-0 z-10 p-4">
            <button id="back-to-home-button" class="btn btn-secondary">
                 Back to Main Menu
            </button>
        </div>
    </div>

    <div id="game-ui" class="w-full max-w-5xl h-screen mx-auto hidden flex flex-col">
        <header class="text-center p-2 flex-shrink-0">
            <h1 class="text-3xl md:text-4xl text-amber-800">Dish & Dash</h1>
            <div class="flex justify-center items-center flex-wrap gap-x-4 gap-y-2 mt-2">
                 <div id="level-display" class="bg-stone-200 text-stone-700 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm"><span>Level: 1</span></div>
                 <div id="order-progress" class="bg-stone-200 text-stone-700 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm"><span>Orders: 0/0</span></div>
                 <div id="star-counter" class="bg-yellow-400/80 text-yellow-900 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm">⭐ <span>0</span></div>
            </div>
            <div id="order-info" class="mt-2 p-3 mx-auto max-w-2xl">
                <div id="customer-type-badge" class="absolute -top-3 -left-3 bg-blue-500 text-white text-xs font-bold px-3 py-1 rounded-full transform -rotate-12 hidden"></div>
                <div id="vip-badge" class="absolute -top-3 -right-3 bg-red-500 text-white text-xs font-bold px-3 py-1 rounded-full transform rotate-12 hidden">VIP!</div>
                <h2 class="text-xl font-semibold text-stone-700">Today's Order:</h2>
                <p id="recipe-name" class="text-3xl font-bold mt-1 text-accent">-</p>
                <div id="recipe-ingredients" class="flex justify-center items-center flex-wrap gap-x-3 gap-y-1 mt-2 text-base font-medium text-stone-600"></div>
                 <div id="timer-container" class="w-full bg-gray-200 rounded-full h-2 mt-3 hidden">
                      <div id="timer-bar" class="bg-red-500 h-2 rounded-full"></div>
                 </div>
            </div>
        </header>

        <main id="plates-container-wrapper" class="flex-grow flex justify-center">
            <div id="plates-container" class="flex flex-col-reverse pt-2 pb-4">
                 <div class="plate-row flex justify-center gap-x-2" style="z-index: 30;">
                     <div class="plate-wrapper"><div id="plate-0" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-1" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-2" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-3" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
                 <div class="plate-row flex justify-center gap-x-2 -mb-8" style="z-index: 20;">
                     <div class="plate-wrapper"><div id="plate-4" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-5" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-6" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
                 <div class="plate-row flex justify-center gap-x-2 -mb-8" style="z-index: 10;">
                     <div class="plate-wrapper"><div id="plate-7" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-8" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-9" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                     <div class="plate-wrapper"><div id="plate-10" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
            </div>
        </main>

        <footer class="flex-shrink-0 py-3 flex justify-center items-center gap-4">
            <button id="back-to-map-button" class="btn btn-secondary">
                View Recipes
            </button>
            <button id="deal-button" class="btn btn-primary" disabled>
                Serve (<span id="deck-count">0</span>)
            </button>
            <button id="trash-can" class="bg-stone-500 hover:bg-stone-600 text-white p-3 rounded-full shadow-lg transition-all duration-300 relative" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" />
                </svg>
                <div id="trash-counter" class="absolute -top-1 -right-1 bg-sky-500 text-white w-6 h-6 rounded-full text-xs font-bold flex items-center justify-center border-2 border-white">0</div>
            </button>
        </footer>
    </div>

    <div id="message-box" class="fixed inset-0 bg-black/40 flex items-center justify-center p-4 opacity-0 pointer-events-none transform scale-95 z-50 transition-all duration-300">
        <div class="w-full max-w-sm mx-auto p-6 text-center">
            <h3 id="message-title" class="text-4xl text-stone-800 mb-4"></h3>
            <p id="message-text" class="text-stone-600 mb-6"></p>
            <div id="message-buttons" class="flex justify-center gap-4">
            </div>
        </div>
    </div>
    
    <div id="how-to-play-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300 z-50">
        <div id="how-to-play-content" class="w-full max-w-md mx-auto max-h-full overflow-y-auto relative transform scale-95 transition-transform duration-300 p-8">
             <button id="how-to-play-close-button-x" class="absolute top-4 right-4 text-stone-400 hover:text-stone-800 z-10">
                 <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
             <h2 class="text-3xl md:text-4xl text-amber-800 mb-6 text-center">How to Play</h2>
             <div class="text-left text-stone-600 space-y-4 text-base">
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">📝</span> <p><strong>The Order:</strong> Your goal is to gather the ingredients on the recipe card.</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">🧐</span> <p><strong>Picky Customers:</strong> Some customers want ingredients in a specific order. Match the highlighted one first!</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">👆</span> <p><strong>Move Stacks:</strong> Click a plate to select the top matching ingredients. Click another plate to move the stack.</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">🏆</span> <p><strong>Golden Ingredients:</strong> These rare items are worth a huge star bonus!</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">🗑️</span> <p><strong>Trash Can:</strong> Discard unwanted ingredients. Uses are limited per level!</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">💣</span> <p><strong>Bomb:</strong> Select a bomb and click any plate to clear all ingredients from it.</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">🌟</span> <p><strong>Wildcard:</strong> This special item can be stacked on anything and counts as any ingredient you need.</p></div>
                 <div class="flex items-start gap-4"> <span class="text-3xl mt-0">⭐</span> <p><strong>Stars:</strong> Earn stars by completing orders. Use them to unlock more plates!</p></div>
             </div>
             <div class="text-center mt-8">
                 <button id="how-to-play-close-button" class="btn btn-primary">Got it!</button>
             </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const MAX_INGREDIENTS_PER_PLATE = 30;
            const DEAL_LIMIT = 15;
            const TOTAL_LEVELS = 100;
            
            let gameState = {
                highestLevelUnlocked: 0,
                currentLevelIndex: 0,
                ordersCompletedInLevel: 0,
                currentRecipe: null,
                plates: [],
                deck: [], 
                selectedStack: null,
                isAnimating: false,
                unlockedIngredients: [],
                stars: 0,
                platesUnlocked: 3,
                trashUsesLeft: 0,
            };
            
            const allPossibleIngredients = ['🍓', '🍌', '🍇', '🥕', '🥦', '🍄', '🍅', '🥑', '🍆', '🌶️'];
            const specialIngredients = ['💣', '🌟', '🏆'];

            const cozyGradientMap = {
                '🍓': 'bg-gradient-to-br from-pink-300 to-red-400',
                '🍌': 'bg-gradient-to-br from-yellow-200 to-yellow-300',
                '🍇': 'bg-gradient-to-br from-purple-300 to-indigo-400',
                '🥕': 'bg-gradient-to-br from-orange-200 to-amber-400',
                '🥦': 'bg-gradient-to-br from-green-300 to-emerald-400',
                '🍄': 'bg-gradient-to-br from-stone-300 to-stone-400',
                '🍅': 'bg-gradient-to-br from-red-400 to-red-500',
                '🥑': 'bg-gradient-to-br from-lime-300 to-green-500',
                '🍆': 'bg-gradient-to-br from-purple-400 to-violet-600',
                '🌶️': 'bg-gradient-to-br from-red-500 to-orange-600',
                '🌟': 'bg-gradient-to-br from-yellow-300 via-amber-300 to-orange-400',
                '💣': 'bg-gradient-to-br from-gray-600 to-black',
                '🏆': 'bg-gradient-to-br from-yellow-300 to-amber-500'
            };


            const homeScreenEl = document.getElementById('home-screen');
            const gameUiEl = document.getElementById('game-ui');
            const levelMapScreenEl = document.getElementById('level-map-screen');
            const levelMapContainer = document.getElementById('level-map-container');
            const startGameButton = document.getElementById('start-game-button');
            const resetProgressButton = document.getElementById('reset-progress-button');
            const backToHomeButton = document.getElementById('back-to-home-button');
            const backToMapButton = document.getElementById('back-to-map-button');
            const dealButton = document.getElementById('deal-button');
            const deckCountEl = document.getElementById('deck-count');
            const recipeNameEl = document.getElementById('recipe-name');
            const recipeIngredientsEl = document.getElementById('recipe-ingredients');
            const levelDisplayEl = document.getElementById('level-display').querySelector('span');
            const orderProgressEl = document.getElementById('order-progress').querySelector('span');
            const starCounterEl = document.getElementById('star-counter').querySelector('span');
            const orderInfoEl = document.getElementById('order-info');
            const animationLayer = document.getElementById('animation-layer');
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const messageButtonsContainer = document.getElementById('message-buttons');
            const timerContainer = document.getElementById('timer-container');
            const timerBar = document.getElementById('timer-bar');
            const vipBadge = document.getElementById('vip-badge');
            const customerTypeBadge = document.getElementById('customer-type-badge');
            const howToPlayButton = document.getElementById('how-to-play-button');
            const howToPlayModal = document.getElementById('how-to-play-modal');
            const howToPlayContent = document.getElementById('how-to-play-content');
            const howToPlayCloseButton = document.getElementById('how-to-play-close-button');
            const howToPlayCloseButtonX = document.getElementById('how-to-play-close-button-x');
            const trashCanEl = document.getElementById('trash-can');
            const trashCounterEl = document.getElementById('trash-counter');

            let timerInterval = null;

            function showMessage(title, text, buttonsConfig) {
                messageTitle.textContent = title;
                messageText.innerHTML = text;
                messageButtonsContainer.innerHTML = ''; 

                if (!buttonsConfig || buttonsConfig.length === 0) {
                     const okButton = document.createElement('button');
                     okButton.textContent = 'Okay!';
                     okButton.className = 'btn btn-primary';
                     okButton.onclick = closeMessage;
                     messageButtonsContainer.appendChild(okButton);
                } else {
                     buttonsConfig.forEach(config => {
                         const button = document.createElement('button');
                         button.textContent = config.text;
                         button.className = `btn ${config.primary ? 'btn-primary' : 'btn-secondary'}`;
                         button.onclick = () => {
                             closeMessage();
                             if (config.action) config.action();
                         };
                         messageButtonsContainer.appendChild(button);
                     });
                }
                
                messageBox.classList.remove('opacity-0', 'pointer-events-none');
                messageBox.querySelector('div').classList.remove('scale-95');
            }

            function closeMessage() {
                messageBox.classList.add('opacity-0');
                setTimeout(() => messageBox.classList.add('pointer-events-none'), 300);
                messageBox.querySelector('div').classList.add('scale-95');
            }
            
            function showScreen(screen) {
                if (timerInterval) clearInterval(timerInterval);
                homeScreenEl.classList.add('hidden');
                gameUiEl.classList.add('hidden');
                levelMapScreenEl.classList.add('hidden');
                screen.classList.remove('hidden');
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            function loadProgress() {
                const savedState = JSON.parse(localStorage.getItem('dishDashGameState'));
                if (savedState) {
                    Object.assign(gameState, savedState);
                }
            }
            
            function saveProgress() {
                localStorage.setItem('dishDashGameState', JSON.stringify(gameState));
            }
            
            function resetProgress() {
                showMessage("Reset Progress", "Are you sure you want to start over? All your stars and unlocked levels will be lost.", [
                    {text: "Cancel", primary: false, action: closeMessage},
                    {text: "Yes, Reset", primary: true, action: () => {
                        localStorage.removeItem('dishDashGameState');
                        Object.assign(gameState, {
                            highestLevelUnlocked: 0, currentLevelIndex: 0, ordersCompletedInLevel: 0,
                            currentRecipe: null, plates: [], deck: [], selectedStack: null,
                            isAnimating: false, unlockedIngredients: [], stars: 0, platesUnlocked: 3,
                            trashUsesLeft: 0,
                        });
                        saveProgress();
                        renderLevelMap();
                        closeMessage();
                    }}
                ]);
            }

            function renderLevelMap() {
                levelMapContainer.innerHTML = '';
                for (let i = 0; i < TOTAL_LEVELS; i++) {
                    const isUnlocked = i <= gameState.highestLevelUnlocked;
                    const nodeContainer = document.createElement('div');
                    nodeContainer.className = 'level-node'; 
                    const button = document.createElement('button');
                    button.disabled = !isUnlocked;
                    button.className = `level-node-button ${isUnlocked ? '' : 'locked'}`;
                    button.onclick = () => startGame(i);
                    
                    const content = document.createElement('div');
                    content.className = 'level-content';

                    if (isUnlocked) {
                        content.innerHTML = `<div class="level-number">${i + 1}</div><div class="level-text-label">Recipe</div>`;
                    } else {
                        content.innerHTML = `<div class="lock-icon-map"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div>`;
                    }
                    button.appendChild(content);
                    nodeContainer.appendChild(button);
                    levelMapContainer.appendChild(nodeContainer);
                }
            }
            
            function showLevelMap() {
                renderLevelMap();
                showScreen(levelMapScreenEl);
            }
            
             function generateLevelData(levelIndex) {
                const levelNumber = levelIndex + 1;
                const ordersToComplete = Math.min(10, 2 + Math.floor(levelIndex / 3));
                const platesActive = Math.min(11, 3 + Math.floor(levelIndex / 2));
                const unlocks = (levelIndex < allPossibleIngredients.length) ? 1 : 0;
                const deckSize = 80 + levelIndex * 15;
                const ingredientCount = Math.min(Math.floor(2 + levelIndex / 3), allPossibleIngredients.length);
                return { id: levelNumber, ordersToComplete, platesActive, deckSize, unlocks, ingredientCount };
            }

            function startGame(levelIndex) {
                showScreen(gameUiEl);
                if(gameState.currentLevelIndex === levelIndex && gameState.currentRecipe) {
                    renderGame();
                    return;
                }
                gameState.currentLevelIndex = levelIndex;
                gameState.ordersCompletedInLevel = 0;
                gameState.plates = Array.from({ length: gameState.platesUnlocked }, () => []);
                gameState.trashUsesLeft = 3 + Math.floor(levelIndex / 5);
                let unlockedCount = 2;
                for(let i = 0; i < levelIndex; i++) {
                    unlockedCount += generateLevelData(i).unlocks || 0;
                }
                gameState.unlockedIngredients = allPossibleIngredients.slice(0, Math.min(unlockedCount, allPossibleIngredients.length));
                serveNewOrder();
            }

            function createDeck(level, ingredientPool, recipe, extraIngredients = []) {
                let newDeck = [...extraIngredients];
                if (recipe && recipe.ingredients) {
                    for (const [ingredient, count] of Object.entries(recipe.ingredients)) {
                        for (let i = 0; i < count; i++) {
                            const isGolden = Math.random() < 0.1;
                            newDeck.push({ type: isGolden ? '🏆' : ingredient, originalType: ingredient, id: `req-${ingredient}-${i}-${Math.random()}` });
                        }
                    }
                }

                const potentialDistractors = allPossibleIngredients.filter(ing => !ingredientPool.includes(ing));
                if (potentialDistractors.length > 0) {
                    const distractor = potentialDistractors[0];
                    for (let i = 0; i < 5; i++) newDeck.push({ type: distractor, id: `distractor-${distractor}-${i}-${Math.random()}`});
                }
                const specialIngredientCount = Math.floor(level.deckSize / 20);
                 for (let i = 0; i < specialIngredientCount; i++) {
                     const type = Math.random() < 0.6 ? '💣' : '🌟';
                     newDeck.push({ type, id: `special-${type}-${i}-${Math.random()}` });
                 }
                const fillerCount = level.deckSize - newDeck.length;
                for (let i = 0; i < fillerCount; i++) {
                    const randomType = ingredientPool[Math.floor(Math.random() * ingredientPool.length)];
                    newDeck.push({ type: randomType, id: `fill-${i}-${Math.random()}` });
                }
                shuffleArray(newDeck);
                return newDeck;
            }
            
            function generateRandomRecipeName() {
                const adjectives = ["Cozy", "Warm", "Golden", "Rustic", "Hearth", "Glimmer", "Twilight", "Cottage"];
                const nouns = ["Delight", "Stew", "Treat", "Feast", "Pie", "Nectar", "Morsel", "Brew"];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                return `${adj} ${noun}`;
            }

            function generateRecipeForLevel(level, unlockedIngredients) {
                const recipeIngredients = {};
                const shuffledPool = [...unlockedIngredients];
                shuffleArray(shuffledPool);
                const ingredientCountForRecipe = Math.min(shuffledPool.length, 3);
                const ingredientsForRecipe = shuffledPool.slice(0, ingredientCountForRecipe);
                ingredientsForRecipe.forEach(ingredient => { recipeIngredients[ingredient] = 10; });
                return { name: generateRandomRecipeName(), ingredients: recipeIngredients };
            }
            
             function startTimer() {
                if (timerInterval) clearInterval(timerInterval);
                const recipe = gameState.currentRecipe;
                if (!recipe || !recipe.isVIP) return;
                timerInterval = setInterval(() => {
                    recipe.timeLeft--;
                    const percentage = (recipe.timeLeft / recipe.timerDuration) * 100;
                    timerBar.style.width = `${percentage}%`;
                    if (recipe.timeLeft <= 0) {
                        clearInterval(timerInterval);
                        showMessage("Time's Up!", "The VIP customer left. Try again!", [{ text: "OK", action: serveNewOrder, primary: true }]);
                    }
                }, 1000);
            }

            function serveNewOrder() {
                if (timerInterval) clearInterval(timerInterval);
                const currentLevel = generateLevelData(gameState.currentLevelIndex);
                gameState.currentRecipe = generateRecipeForLevel(currentLevel, gameState.unlockedIngredients);
                gameState.currentRecipe.isVIP = false;
                gameState.currentRecipe.customerType = 'normal';
                const randomCustomer = Math.random();
                if (gameState.currentLevelIndex >= 5 && randomCustomer < 0.3) {
                    gameState.currentRecipe.customerType = 'picky';
                    const order = [];
                    for(const [ing, count] of Object.entries(gameState.currentRecipe.ingredients)) {
                        for(let i=0; i < count; i++) order.push(ing);
                    }
                    shuffleArray(order);
                    gameState.currentRecipe.ingredientOrder = order;
                } else if (gameState.currentLevelIndex >= 2 && randomCustomer < 0.5) {
                    gameState.currentRecipe.isVIP = true;
                    gameState.currentRecipe.timerDuration = 60;
                    gameState.currentRecipe.timeLeft = 60;
                    startTimer();
                }
                gameState.currentRecipe.needed = { ...gameState.currentRecipe.ingredients };
                gameState.deck = createDeck(currentLevel, gameState.unlockedIngredients, gameState.currentRecipe);
                gameState.selectedStack = null;
                saveProgress();
                renderGame();
            }

            function dealRow() {
                if (gameState.isAnimating || gameState.deck.length === 0) return;
                if (gameState.selectedStack) gameState.selectedStack = null;
                const deals = [];
                const availablePlates = gameState.plates.map((p, i) => i).filter(i => gameState.plates[i].length < DEAL_LIMIT);
                if (availablePlates.length === 0) {
                    dealButton.classList.add('shake');
                    setTimeout(() => dealButton.classList.remove('shake'), 500);
                    return;
                }
                shuffleArray(availablePlates);
                const neededTypes = Object.keys(gameState.currentRecipe.needed).filter(type => gameState.currentRecipe.needed[type] > 0);
                let priorityDeck = gameState.deck.filter(ing => neededTypes.includes(ing.type) || neededTypes.includes(ing.originalType));
                let regularDeck = gameState.deck.filter(ing => !priorityDeck.includes(ing));
                availablePlates.forEach(plateIndex => {
                    const countToServe = Math.floor(Math.random() * 3) + 1;
                    let servedToThisPlate = 0;
                    for (let i = 0; i < countToServe; i++) {
                        if (gameState.plates[plateIndex].length + servedToThisPlate >= DEAL_LIMIT) break; 
                        let ingredientToDeal = null;
                        const pullFromPriority = Math.random() < 0.4;
                        if (pullFromPriority && priorityDeck.length > 0) ingredientToDeal = priorityDeck.pop();
                        else if (regularDeck.length > 0) ingredientToDeal = regularDeck.pop();
                        else if (priorityDeck.length > 0) ingredientToDeal = priorityDeck.pop();
                        else break; 
                        if (ingredientToDeal) {
                            deals.push({ toPlateIndex: plateIndex, ingredient: ingredientToDeal });
                            servedToThisPlate++;
                        }
                    }
                });
                gameState.deck = [...priorityDeck, ...regularDeck];
                shuffleArray(gameState.deck);
                if (deals.length > 0) animateDeal(deals);
            }

            function renderGame() {
                const recipe = gameState.currentRecipe;
                if (!recipe) return;
                const currentLevel = generateLevelData(gameState.currentLevelIndex);
                levelDisplayEl.textContent = `Level: ${gameState.currentLevelIndex + 1}`;
                orderProgressEl.textContent = `Orders: ${gameState.ordersCompletedInLevel + 1}/${currentLevel.ordersToComplete}`;
                starCounterEl.textContent = gameState.stars;
                recipeNameEl.textContent = recipe.name;
                vipBadge.classList.toggle('hidden', !recipe.isVIP);
                customerTypeBadge.classList.toggle('hidden', recipe.customerType !== 'picky');
                if(recipe.customerType === 'picky') customerTypeBadge.textContent = 'In Order!';
                timerContainer.classList.toggle('hidden', !recipe.isVIP);
                if (recipe.isVIP) {
                    const percentage = (recipe.timeLeft / recipe.timerDuration) * 100;
                    timerBar.style.width = `${percentage}%`;
                }
                recipeIngredientsEl.innerHTML = '';
                if(recipe.customerType === 'picky') {
                    recipe.ingredientOrder.forEach((emoji, index) => {
                        const span = document.createElement('span');
                        span.className = 'recipe-ingredient-ordered';
                        if (index === 0) span.classList.add('next-in-order');
                        span.textContent = emoji;
                        recipeIngredientsEl.appendChild(span);
                    });
                } else {
                    recipeIngredientsEl.innerHTML = Object.entries(recipe.ingredients)
                        .map(([emoji, targetCount]) => `<span class="recipe-ingredient ${recipe.needed[emoji] <= 0 ? 'done' : ''}">${emoji} x${Math.max(0, recipe.needed[emoji])}</span>`)
                        .join(' ');
                }
                document.querySelectorAll('.plate-wrapper').forEach((wrapper, index) => {
                    const plateArea = wrapper.querySelector('.plate-area');
                    const isActive = index < gameState.platesUnlocked;
                    plateArea.classList.remove('potential-target', 'bomb-target');
                    if (isActive) {
                        plateArea.classList.remove('locked');
                        const plate = gameState.plates[index];
                        plateArea.innerHTML = '';
                        wrapper.onclick = () => handlePlateClick(index);
                        if (plate) {
                            plate.forEach((ingredient, ingredientIndex) => {
                                const ingredientEl = createAnimatedClone(ingredient);
                                let transformValue = `translateX(-50%) translateZ(${ingredientIndex * 5}px)`;
                                if (gameState.selectedStack?.fromPlate === index && gameState.selectedStack.stack.some(s => s.id === ingredient.id)) {
                                     transformValue += ' translateZ(25px) scale(1.05)'; 
                                     if(ingredientIndex === plate.length - 1) {
                                         const counter = document.createElement('div');
                                         counter.className = 'stack-counter';
                                         counter.textContent = gameState.selectedStack.stack.length;
                                         ingredientEl.appendChild(counter);
                                     }
                                }
                                ingredientEl.style.transform = transformValue;
                                ingredientEl.style.setProperty('--transform-stack', transformValue);
                                if (ingredient.isNew) {
                                     ingredientEl.style.setProperty('--transform-stack-initial', `translateX(-50%) translateZ(${(ingredientIndex -1) * 5}px)`);
                                     ingredientEl.classList.add('deal-in-animation');
                                     delete ingredient.isNew;
                                }
                                plateArea.appendChild(ingredientEl);
                            });
                        }
                        if (gameState.selectedStack?.stack?.length > 0) {
                             const type = gameState.selectedStack.stack[0].type;
                             if(type === '💣') plateArea.classList.add('bomb-target');
                             else if (canMoveStackTo(gameState.selectedStack.stack, plate)) plateArea.classList.add('potential-target');
                        }
                    } else {
                        plateArea.classList.add('locked');
                        plateArea.innerHTML = `<div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div>`;
                        wrapper.onclick = () => handleUnlockPlateClick(); 
                    }
                });
                orderInfoEl.classList.toggle('targetable', isStackDeliverable(gameState.selectedStack));
                trashCanEl.disabled = !gameState.selectedStack || gameState.trashUsesLeft <= 0 || (gameState.selectedStack && gameState.selectedStack.stack[0].type === '💣');
                trashCounterEl.textContent = gameState.trashUsesLeft;
                const allPlatesFull = gameState.plates.every(p => p.length >= MAX_INGREDIENTS_PER_PLATE);
                dealButton.disabled = allPlatesFull || isOrderComplete();
                deckCountEl.textContent = gameState.deck.length;
            }

            function handlePlateClick(plateIndex) {
                if (gameState.isAnimating) return;
                const clickedPlate = gameState.plates[plateIndex];
                if (!gameState.selectedStack) {
                    if (clickedPlate.length === 0) return;
                    const topIngredient = clickedPlate[clickedPlate.length - 1];
                    const topType = topIngredient.type;
                    const topOriginalType = topIngredient.originalType || topIngredient.type;
                    const movableStack = [];
                    for (let i = clickedPlate.length - 1; i >= 0; i--) {
                        const currentIngredient = clickedPlate[i];
                        const currentOriginalType = currentIngredient.originalType || currentIngredient.type;
                        if (currentOriginalType === topOriginalType && currentIngredient.type === topType) { 
                            movableStack.unshift(currentIngredient);
                        } else break;
                    }
                    gameState.selectedStack = { fromPlate: plateIndex, stack: movableStack };
                } else {
                    const { fromPlate, stack } = gameState.selectedStack;
                    if (stack[0].type === '💣') {
                        clearPlateWithBomb(plateIndex, fromPlate);
                        return;
                    }
                    if (fromPlate === plateIndex) gameState.selectedStack = null;
                    else if (canMoveStackTo(stack, clickedPlate)) moveStack(plateIndex);
                    else {
                        const plateWrapperEl = document.getElementById(`plate-${plateIndex}`).parentElement;
                        plateWrapperEl.classList.add('shake');
                        setTimeout(() => plateWrapperEl.classList.remove('shake'), 500);
                        gameState.selectedStack = null;
                    }
                }
                renderGame();
            }
            
            function canMoveStackTo(stack, destinationPlate) {
                if (destinationPlate.length + stack.length > MAX_INGREDIENTS_PER_PLATE || !stack || stack.length === 0) return false;
                const stackType = stack[0].type;
                if (['💣', '🤢'].includes(stackType)) return false; 
                if (destinationPlate.length === 0) return true;
                const destType = destinationPlate[destinationPlate.length - 1].type;
                if (['💣', '🤢'].includes(destType)) return false;
                if (stackType === '🌟' || destType === '🌟') return true;
                return (stack[0].originalType || stackType) === (destinationPlate[destinationPlate.length-1].originalType || destType);
            }
            
            function createAnimatedClone(ingredientData) {
                const clone = document.createElement('div');
                clone.className = 'ingredient';

                const gradientClasses = (cozyGradientMap[ingredientData.originalType || ingredientData.type] || 'bg-stone-200').split(' ');
                clone.classList.add(...gradientClasses);

                if(ingredientData.type === '🏆') clone.classList.add('golden');

                const inner = document.createElement('div');
                inner.className = 'ingredient-inner';
                inner.textContent = ingredientData.type;
                
                clone.appendChild(inner);
                return clone;
            }

            function handleRecipeClick() {
                if (gameState.isAnimating || !isStackDeliverable(gameState.selectedStack)) {
                    if (gameState.selectedStack) {
                        orderInfoEl.classList.add('shake');
                        setTimeout(() => orderInfoEl.classList.remove('shake'), 500);
                        gameState.selectedStack = null;
                        renderGame();
                    }
                    return;
                }
                const { fromPlate, stack } = gameState.selectedStack;
                const type = stack[0].type;
                const originalType = stack[0].originalType || type;
                gameState.isAnimating = true;
                if (gameState.currentRecipe.customerType === 'picky') {
                    if (type === '🌟' || type === '🏆' || originalType === gameState.currentRecipe.ingredientOrder[0]) {
                       gameState.currentRecipe.ingredientOrder.splice(0, stack.length);
                    }
                } else if (type === '🌟') {
                    const neededIngredient = Object.keys(gameState.currentRecipe.needed).find(key => gameState.currentRecipe.needed[key] > 0);
                    if (neededIngredient) gameState.currentRecipe.needed[neededIngredient] -= stack.length;
                } else {
                    gameState.currentRecipe.needed[originalType] -= stack.length;
                }
                let starsEarned = type === '🏆' ? 50 : 15;
                if(gameState.currentRecipe.isVIP) starsEarned += 20;
                if(gameState.currentRecipe.customerType === 'picky') starsEarned += 10;
                gameState.stars += starsEarned;
                gameState.selectedStack = null;
                const deliveredIngredients = gameState.plates[fromPlate].splice(-stack.length);
                renderGame(); 
                const orderRect = orderInfoEl.getBoundingClientRect();
                const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect();
                deliveredIngredients.reverse().forEach((ingredientData, index) => {
                    const clone = createAnimatedClone(ingredientData);
                    Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.4s cubic-bezier(0.5, -0.5, 0.75, 1.2)', left: `${startRect.left + (startRect.width / 2) - 20}px`, top: `${startRect.top + (startRect.height / 2) - 20}px` });
                    animationLayer.appendChild(clone);
                    setTimeout(() => Object.assign(clone.style, { left: `${orderRect.left + (orderRect.width / 2) - 20}px`, top: `${orderRect.top + (orderRect.height / 2) - 20}px`, transform: 'scale(0.5)', opacity: '0' }), index * 50);
                    setTimeout(() => {
                        clone.remove();
                        if (index === deliveredIngredients.length - 1) {
                            gameState.isAnimating = false;
                            if (isOrderComplete()) handleOrderCompletion(); else { saveProgress(); renderGame(); }
                        }
                    }, index * 50 + 400); 
                });
            }

            function moveStack(toPlateIndex) {
                 if (gameState.isAnimating) return;
                 const { fromPlate, stack } = gameState.selectedStack;
                 gameState.isAnimating = true;
                 gameState.selectedStack = null;
                 gameState.plates[fromPlate].splice(-stack.length);
                 renderGame();
                 const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect();
                 const endRect = document.getElementById(`plate-${toPlateIndex}`).parentElement.getBoundingClientRect();
                 stack.slice().reverse().forEach((ingredientData, index) => {
                     const clone = createAnimatedClone(ingredientData);
                     Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.4s cubic-bezier(0.5, -0.5, 0.75, 1.2)', left: `${startRect.left + (startRect.width / 2) - 20}px`, top: `${startRect.top + (startRect.height / 2) - 20}px`, transform: `translateZ(${ (gameState.plates[fromPlate].length + stack.length - index) * 5 }px) scale(1.1)` });
                     animationLayer.appendChild(clone);
                     setTimeout(() => Object.assign(clone.style, { left: `${endRect.left + (endRect.width / 2) - 20}px`, top: `${endRect.top + (endRect.height / 2) - 20}px`, transform: `translateZ(${ (gameState.plates[toPlateIndex].length + stack.length - index) * 5 }px) scale(1)` }), index * 40);
                     setTimeout(() => {
                         clone.remove();
                         if (index === stack.length - 1) {
                             gameState.plates[toPlateIndex].push(...stack);
                             saveProgress();
                             gameState.isAnimating = false;
                             renderGame();
                         }
                     }, index * 40 + 400);
                 });
            }

            function animateDeal(deals) {
                gameState.isAnimating = true;
                const dealButtonRect = dealButton.getBoundingClientRect();
                deals.forEach((deal, dealIndex) => {
                    const { toPlateIndex, ingredient } = deal;
                    const endRect = document.getElementById(`plate-${toPlateIndex}`).parentElement.getBoundingClientRect();
                    const clone = createAnimatedClone(ingredient);
                    Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - dealIndex, transition: 'all 0.4s cubic-bezier(0.3, 0, 0.4, 1), opacity 0.3s ease-in-out', left: `${dealButtonRect.left + (dealButtonRect.width / 2) - 20}px`, top: `${dealButtonRect.top + (dealButtonRect.height / 2) - 20}px`, transform: 'scale(0.8)', opacity: '0' });
                    animationLayer.appendChild(clone);
                    setTimeout(() => Object.assign(clone.style, { opacity: '1', left: `${endRect.left + (endRect.width / 2) - 20}px`, top: `${endRect.top + (endRect.height / 2) - 20}px`, transform: `scale(1) translateZ(${gameState.plates[toPlateIndex].length * 5}px)` }), 50 + dealIndex * 70); 
                    setTimeout(() => {
                        clone.remove();
                        if (dealIndex === deals.length - 1) {
                            deals.forEach(d => { d.ingredient.isNew = true; gameState.plates[d.toPlateIndex].push(d.ingredient); });
                            saveProgress();
                            gameState.isAnimating = false;
                            renderGame();
                        }
                    }, 50 + dealIndex * 70 + 400);
                });
            }
            
            function isStackDeliverable(selectedStack) {
                if (!selectedStack) return false;
                const recipe = gameState.currentRecipe;
                if (!recipe) return false;
                const { stack } = selectedStack;
                if (stack.length === 0) return false;
                const type = stack[0].type;
                const originalType = stack[0].originalType || type;
                if (type === '🤢') return false;
                if (recipe.customerType === 'picky') {
                    if (recipe.ingredientOrder.length === 0) return false;
                    return type === '🌟' || originalType === recipe.ingredientOrder[0];
                }
                return type === '🌟' ? Object.values(recipe.needed).some(c => c > 0) : recipe.needed[originalType] > 0;
            }

            function isOrderComplete() {
                if (!gameState.currentRecipe) return false;
                if(gameState.currentRecipe.customerType === 'picky') return gameState.currentRecipe.ingredientOrder.length === 0;
                return Object.values(gameState.currentRecipe.needed).every(count => count <= 0);
            }
            
            function handleOrderCompletion() {
                if(timerInterval) clearInterval(timerInterval);
                gameState.ordersCompletedInLevel++;
                const currentLevel = generateLevelData(gameState.currentLevelIndex);
                if(gameState.ordersCompletedInLevel >= currentLevel.ordersToComplete) handleLevelComplete();
                else serveNewOrder();
            }

            function checkAndHandleStuckState() {
                showMessage("Empty Deck!", "No more ingredients left. Refilling the deck for you!");
                const currentLevel = generateLevelData(gameState.currentLevelIndex);
                const missingIngredientsRecipe = { ingredients: gameState.currentRecipe.needed };
                gameState.deck = createDeck(currentLevel, gameState.unlockedIngredients, missingIngredientsRecipe);
                renderGame();
            }
            
            function handleLevelComplete() {
                if (gameState.currentLevelIndex >= gameState.highestLevelUnlocked) {
                    gameState.highestLevelUnlocked = gameState.currentLevelIndex + 1;
                }
                gameState.currentRecipe = null;
                saveProgress();
                const onConfirm = () => {
                    if (gameState.currentLevelIndex >= TOTAL_LEVELS - 1) handleGameWon();
                    else {
                        gameState.currentLevelIndex++;
                        gameState.ordersCompletedInLevel = 0;
                        startGame(gameState.currentLevelIndex);
                    }
                };
                showMessage("Recipe Complete!", `You've unlocked the next recipe!`, [{ text: "Next Recipe", action: onConfirm, primary: true }]);
            }
            
            function handleGameWon() {
                showMessage("Congratulations!", "You've mastered the cozy kitchen!", [{ text: "Play Again", action: () => showScreen(homeScreenEl), primary: true }]);
            }
            
            function handleUnlockPlateClick() {
                if (gameState.platesUnlocked >= 11) return;
                const cost = 1150 + (gameState.platesUnlocked - 3) * 500;
                if (gameState.stars >= cost) {
                    showMessage("Unlock Plate", `Spend ${cost} ⭐ to unlock this plate?`, [
                        { text: "Not now", primary: false },
                        { text: "Unlock", primary: true, action: () => {
                            gameState.stars -= cost;
                            gameState.platesUnlocked++;
                            gameState.plates.push([]);
                            saveProgress(); renderGame();
                        }}
                    ]);
                } else {
                    showMessage("Not Enough Stars!", `You need ${cost} ⭐ to unlock this plate.`, [{ text: 'OK', primary: true }]);
                }
            }

            function handleTrashClick() {
                if (gameState.isAnimating || !gameState.selectedStack || gameState.trashUsesLeft <= 0) return;
                const { fromPlate, stack } = gameState.selectedStack;
                if (stack[0].type === '💣') return;
                gameState.trashUsesLeft--;
                gameState.isAnimating = true;
                gameState.selectedStack = null;
                const trashedIngredients = gameState.plates[fromPlate].splice(-stack.length);
                renderGame();
                const trashRect = trashCanEl.getBoundingClientRect();
                const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect();
                trashedIngredients.reverse().forEach((ingredientData, index) => {
                    const clone = createAnimatedClone(ingredientData);
                    Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.5s cubic-bezier(0.5, -0.5, 0.2, 1)', left: `${startRect.left + (startRect.width / 2) - 20}px`, top: `${startRect.top + (startRect.height / 2) - 20}px` });
                    animationLayer.appendChild(clone);
                    setTimeout(() => Object.assign(clone.style, { left: `${trashRect.left + (trashRect.width / 2) - 15}px`, top: `${trashRect.top + (trashRect.height / 2) - 15}px`, transform: 'scale(0.3)', opacity: '0' }), index * 50);
                    setTimeout(() => {
                        clone.remove();
                        if(index === trashedIngredients.length - 1) {
                            gameState.isAnimating = false;
                            saveProgress(); renderGame();
                        }
                    }, index * 50 + 500);
                });
            }

            function clearPlateWithBomb(targetPlateIndex, bombPlateIndex) {
                 if (gameState.isAnimating) return;
                 gameState.isAnimating = true;
                 gameState.selectedStack = null;
                 gameState.plates[bombPlateIndex].pop();
                 const ingredientsToClear = [...gameState.plates[targetPlateIndex]];
                 gameState.plates[targetPlateIndex] = [];
                 renderGame();
                 const targetRect = document.getElementById(`plate-${targetPlateIndex}`).parentElement.getBoundingClientRect();
                 if(ingredientsToClear.length === 0) {
                      gameState.isAnimating = false;
                      saveProgress(); renderGame();
                      return;
                 }
                 ingredientsToClear.forEach((ingredient, index) => {
                     const clone = createAnimatedClone(ingredient);
                     Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.5s ease-out', left: `${targetRect.left + (targetRect.width / 2) - 20}px`, top: `${targetRect.top + (targetRect.height / 2) - 20}px` });
                     animationLayer.appendChild(clone);
                     setTimeout(() => {
                         const angle = Math.random() * 2 * Math.PI, distance = 150 + Math.random() * 50;
                         clone.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0.5) rotate(${Math.random() * 360}deg)`;
                         clone.style.opacity = '0';
                     }, 50);
                     setTimeout(() => {
                         clone.remove();
                         if(index === ingredientsToClear.length - 1) {
                             gameState.isAnimating = false;
                             saveProgress(); renderGame();
                         }
                     }, 550);
                 });
            }
            
            // --- INITIALIZATION & LISTENERS ---
            loadProgress();
            
            startGameButton.addEventListener('click', showLevelMap);
            resetProgressButton.addEventListener('click', resetProgress);
            backToHomeButton.addEventListener('click', () => showScreen(homeScreenEl));
            backToMapButton.addEventListener('click', showLevelMap);
            dealButton.addEventListener('click', dealRow);
            orderInfoEl.addEventListener('click', handleRecipeClick);
            trashCanEl.addEventListener('click', handleTrashClick);
            
            const openHowToPlayModal = () => {
                howToPlayModal.classList.remove('opacity-0', 'pointer-events-none');
                howToPlayContent.classList.remove('scale-95');
            };
            const closeHowToPlayModal = () => {
                howToPlayModal.classList.add('opacity-0');
                howToPlayContent.classList.add('scale-95');
                setTimeout(() => howToPlayModal.classList.add('pointer-events-none'), 300);
            };

            howToPlayButton.addEventListener('click', openHowToPlayModal);
            howToPlayCloseButton.addEventListener('click', closeHowToPlayModal);
            howToPlayCloseButtonX.addEventListener('click', closeHowToPlayModal);
            howToPlayModal.addEventListener('click', (e) => e.target === howToPlayModal && closeHowToPlayModal());
        });
    </script>
</body>
</html>
