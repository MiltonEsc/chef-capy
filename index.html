<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dish & Dash - Cozy Kitchen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg-cozy: #FBF7F3;
            --text-dark: #4a403a;
            --text-light: #7a6c62;
            --primary: #a3b18a;
            --primary-hover: #919d7a;
            --secondary: #e7c8a0;
            --secondary-hover: #d7b58c;
            --accent: #d4a373;
            --danger: #c78080;
            --locked: #a8a29e;
        }

        body {
            font-family: 'Comfortaa', cursive;
            background-color: var(--bg-cozy);
            color: var(--text-dark);
            background-image: url("data:image/svg+xml,%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23d4a373' fill-opacity='0.1'%3E%3Cpath d='M80 80V0h-29.333c1.05 4.333 1.575 8.833 1.575 13.5C52.242 27.667 45.575 39.583 36.417 46.5c-4.583 3.45-9.25 5.175-14 5.175-3.267 0-6.417-.833-9.5-2.5C11.083 47.333 9.417 44.833 7.5 41.5c-2.417-4.167-3.5-8.5-3.5-13C4 21.333 5.333 15.167 8 9.5V0H0v80h80z'/%3E%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            overflow: hidden;
        }

        h1, h2, #message-title, #recipe-name {
             font-family: 'Kalam', cursive;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            border-bottom: 4px solid rgba(0,0,0,0.2);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .btn:active:not(:disabled) {
            transform: translateY(1px);
            border-bottom-width: 2px;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-dark); }
        .btn-secondary:hover:not(:disabled) { background-color: var(--secondary-hover); }
        .btn-danger { background-color: var(--danger); color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #b96f6f; }
        
        #game-ui, #plate-tower-game { perspective: 1500px; }

        #level-map-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 2rem;
            padding: 2rem;
            justify-items: center;
        }
        .level-node-button {
            width: 120px;
            height: 150px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Kalam', cursive;
            color: var(--text-dark);
            border: 1px solid #e5e5e5;
        }
        .level-node-button:not(:disabled):hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 15px rgba(0,0,0,0.15);
        }
        .level-node-button.locked {
            background: #d6d3d1;
            filter: grayscale(80%);
            cursor: not-allowed;
        }
        .level-node-button::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%) rotate(-3deg);
            width: 60px;
            height: 25px;
            background: var(--secondary);
            opacity: 0.6;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .level-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        .level-number { font-size: 3rem; font-weight: 700; line-height: 1; color: var(--accent); }
        .level-text-label { font-size: 1rem; }
        .lock-icon-map { width: 40px; height: 40px; color: rgba(0,0,0,0.3); }

        #order-info {
            background: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            background-image: linear-gradient(#f9fafb 1.1rem, #e5e7eb 1.1rem);
            background-size: 100% 2.2rem;
            padding-top: 2rem;
        }
        #order-info::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 1rem;
            right: 1rem;
            height: 10px;
            background-image: radial-gradient(#d6d3d1 2px, transparent 2px);
            background-size: 20px 10px;
            background-repeat: repeat-x;
        }
        /* Style for small ingredient images in the recipe list */
        .recipe-img {
            display: inline-block;
            width: 1.5rem; /* 24px */
            height: 1.5rem; /* 24px */
            vertical-align: middle;
            margin: 0 0.125rem;
        }

        .plate-wrapper {
            perspective: 1000px;
            transform-style: preserve-3d;
            display: flex;
            justify-content: center;
            align-items: flex-end; 
            height: 7rem;
            position: relative;
        }

        .plate-area {
            width: calc(4.2rem + 8px); 
            height: calc(4.2rem + 8px);
            background: radial-gradient(circle, #f8f8f8 70%, #e0e0e0 100%);
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1), 0 10px 15px rgba(0,0,0,0.1);
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(30deg) rotateZ(314deg);
        }
        
        .lock-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(2px);
            width: 2.5rem;
            height: 2.5rem;
            display: none;
            z-index: 10;
        }
        
        .plate-area.locked .lock-icon { display: block; }

        .ingredient {
            position: absolute; bottom: 0px; left: 50%;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom center; pointer-events: none; user-select: none;
            width: 4.5rem; height: 4.5rem;
            display: flex; align-items: center; justify-content: center;
            transform: translateX(-50%); border-radius: 9999px; padding: 6px; 
        }
        .ingredient-inner {
            width: 100%; height: 100%; border-radius: 9999px;
            background: radial-gradient(circle, #ffffff 60%, #f0efeb 100%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            display: flex; align-items: center; justify-content: center;
        }
        .ingredient-inner img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 9999px;
        }
        .ingredient.golden .ingredient-inner {
            filter: drop-shadow(0 0 8px gold) drop-shadow(0 0 3px #fff);
            background: radial-gradient(circle, #fffef5 60%, #f0efeb 100%);
        }

        #message-box > div, #how-to-play-content {
            background-color: var(--bg-cozy);
            border: 5px solid var(--accent);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-radius: 20px;
        }
        
        .stack-counter {
            position: absolute; top: -5px; right: -5px;
            background-color: #ef4444; color: white; border-radius: 50%;
            width: 1.75rem; height: 1.75rem; font-size: 0.85rem; font-weight: 700;
            display: flex; align-items: center; justify-content: center;
            pointer-events: none; z-index: 10; border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3); font-family: 'Comfortaa', cursive;
        }
    </style>
</head>
<body class="text-stone-800">
    
    <div id="animation-layer" class="fixed inset-0 pointer-events-none z-50"></div>

    <div id="home-screen" class="flex flex-col items-center justify-center text-center h-screen p-4">
        <div class="my-4 animate-bounce">
            <img src="https://placehold.co/128x128/a3b18a/FBF7F3?text=D%26D&font=kalam" alt="Logo de Dish & Dash" class="w-32 h-32 rounded-full object-cover shadow-lg border-4 border-white">
        </div>
        <h1 class="text-7xl md:text-9xl text-amber-800">Dish & Dash</h1>
        <p class="text-2xl text-stone-600 my-4">Un rompecabezas de cocina</p>
        <p id="user-greeting" class="text-xl text-stone-500 max-w-md mb-8">Â¡Por favor, inicia sesiÃ³n para empezar a cocinar!</p>
        
        <button id="login-button" class="btn btn-primary text-2xl">
            <span class="flex items-center gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20.283 10.356h-8.327v3.451h4.792c-.446 2.193-2.313 3.453-4.792 3.453a5.27 5.27 0 0 1-5.279-5.28 5.27 5.27 0 0 1 5.279-5.279c1.259 0 2.397.447 3.29 1.178l2.6-2.599c-1.584-1.381-3.615-2.233-5.89-2.233a8.908 8.908 0 0 0-8.934 8.934 8.907 8.907 0 0 0 8.934 8.934c4.956 0 8.327-3.453 8.327-8.546 0-.533-.063-1.036-.121-1.472z"></path></svg> Iniciar sesiÃ³n con Google</span>
        </button>

        <button id="start-game-button" class="btn btn-primary text-2xl hidden">
            Â¡Empezar a cocinar!
        </button>
        <div class="mt-4 flex gap-4">
            <button id="how-to-play-button" class="btn btn-secondary text-sm">
                CÃ³mo Jugar
            </button>
            <button id="reset-progress-button" class="btn btn-danger text-sm hidden">
                Reiniciar Progreso
            </button>
             <button id="logout-button" class="btn btn-secondary text-sm hidden">
                Cerrar SesiÃ³n
            </button>
       </div>
    </div>
    
    <div id="level-map-screen" class="w-full h-screen mx-auto hidden flex flex-col relative overflow-hidden">
        <div class="flex-shrink-0 text-center z-10 p-6">
            <h2 class="text-5xl md:text-6xl text-amber-900" style="text-shadow: 2px 2px 0px #FBF7F3;">Selecciona una Receta</h2>
        </div>
        <div class="flex-grow overflow-y-auto z-10">
             <div id="level-map-container">
                </div>
        </div>
         <div class="text-center flex-shrink-0 z-10 p-4">
            <button id="back-to-home-button" class="btn btn-secondary">
                 Volver al MenÃº Principal
            </button>
        </div>
    </div>

    <div id="game-ui" class="w-full max-w-5xl h-screen mx-auto hidden flex flex-col">
        <header class="text-center p-2 flex-shrink-0">
            <h1 class="text-3xl md:text-4xl text-amber-800">Dish & Dash</h1>
            <div class="flex justify-center items-center flex-wrap gap-x-4 gap-y-2 mt-2">
                 <div id="level-display" class="bg-stone-200 text-stone-700 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm"><span>Nivel: 1</span></div>
                 <div id="order-progress" class="bg-stone-200 text-stone-700 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm"><span>Pedidos: 0/0</span></div>
                 <div id="star-counter" class="bg-yellow-400/80 text-yellow-900 px-3 py-1 rounded-lg shadow-sm flex items-center gap-2 text-sm"><img src="/img/corbys.png" alt="Estrella" class="w-4 h-4"> <span>0</span></div>
            </div>
            <div id="order-info" class="mt-2 p-3 mx-auto max-w-2xl">
                <div id="customer-type-badge" class="absolute -top-3 -left-3 bg-blue-500 text-white text-xs font-bold px-3 py-1 rounded-full transform -rotate-12 hidden"></div>
                <div id="vip-badge" class="absolute -top-3 -right-3 bg-red-500 text-white text-xs font-bold px-3 py-1 rounded-full transform rotate-12 hidden">VIP!</div>
                <h2 class="text-xl font-semibold text-stone-700">Pedido de Hoy:</h2>
                <p id="recipe-name" class="text-3xl font-bold mt-1 text-accent">-</p>
                <div id="recipe-ingredients" class="flex justify-center items-center flex-wrap gap-x-3 gap-y-1 mt-2 text-base font-medium text-stone-600"></div>
                 <div id="timer-container" class="w-full bg-gray-200 rounded-full h-2 mt-3 hidden">
                      <div id="timer-bar" class="bg-red-500 h-2 rounded-full"></div>
                 </div>
            </div>
        </header>
        <main id="plates-container-wrapper" class="flex-grow flex justify-center">
            <div id="plates-container" class="flex flex-col-reverse pt-2 pb-4">
                 <div class="plate-row flex justify-center gap-x-2" style="z-index: 30;">
                      <div class="plate-wrapper"><div id="plate-0" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-1" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-2" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-3" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
                 <div class="plate-row flex justify-center gap-x-2 -mb-8" style="z-index: 20;">
                      <div class="plate-wrapper"><div id="plate-4" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-5" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-6" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
                 <div class="plate-row flex justify-center gap-x-2 -mb-8" style="z-index: 10;">
                      <div class="plate-wrapper"><div id="plate-7" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-8" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-9" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                      <div class="plate-wrapper"><div id="plate-10" class="plate-area"><div class="lock-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div></div></div>
                 </div>
            </div>
        </main>
        <footer class="flex-shrink-0 py-3 flex justify-center items-center gap-4">
            <button id="back-to-map-button" class="btn btn-secondary"> Ver Recetas </button>
            <button id="deal-button" class="btn btn-primary" disabled> Servir (<span id="deck-count">0</span>) </button>
            <button id="trash-can" class="bg-stone-500 hover:bg-stone-600 text-white p-3 rounded-full shadow-lg transition-all duration-300 relative" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" />
                </svg>
                <div id="trash-counter" class="absolute -top-1 -right-1 bg-sky-500 text-white w-6 h-6 rounded-full text-xs font-bold flex items-center justify-center border-2 border-white">0</div>
            </button>
        </footer>
    </div>

    <div id="message-box" class="fixed inset-0 bg-black/40 flex items-center justify-center p-4 opacity-0 pointer-events-none transform scale-95 z-50 transition-all duration-300">
        <div class="w-full max-w-sm mx-auto p-6 text-center">
            <h3 id="message-title" class="text-4xl text-stone-800 mb-4"></h3>
            <p id="message-text" class="text-stone-600 mb-6"></p>
            <div id="message-buttons" class="flex justify-center gap-4">
            </div>
        </div>
    </div>
    <div id="how-to-play-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300 z-50">
        <div id="how-to-play-content" class="w-full max-w-md mx-auto max-h-full overflow-y-auto relative transform scale-95 transition-transform duration-300 p-8">
             <button id="how-to-play-close-button-x" class="absolute top-4 right-4 text-stone-400 hover:text-stone-800 z-10">
                 <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
             <h2 class="text-3xl md:text-4xl text-amber-800 mb-6 text-center">CÃ³mo Jugar</h2>
             <div class="text-left text-stone-600 space-y-4 text-base">
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/note.png" alt="Recetas"></span> <p><strong>El Pedido:</strong> Tu objetivo es reunir los ingredientes de la tarjeta de receta. Para recetas normales, debes crear una pila de la cantidad exacta (o mÃ¡s) y entregarla toda junta.</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/time.png" alt="Cliente exigente"></span> <p><strong>Clientes Exigentes:</strong> Algunos clientes quieren los ingredientes en un orden especÃ­fico. Â¡Coincide primero con el resaltado!</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/upfinger.png" alt="Mover Pilas"></span> <p><strong>Mover Pilas:</strong> Haz clic en un plato para seleccionar los ingredientes superiores que coincidan. Haz clic en otro plato para mover la pila.</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/golden.png" alt="Ingrediente Dorado"></span> <p><strong>Ingredientes Dorados:</strong> Â¡Estos raros artÃ­culos valen una enorme bonificaciÃ³n de estrellas!</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/trash.png" alt="ComodÃ­n"></span> <p><strong>Bote de Basura:</strong> Descarta los ingredientes no deseados. Â¡Los usos son limitados por nivel!</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/bomb.png" alt="Bomba"></span> <p><strong>Bomba:</strong> Selecciona una bomba y haz clic en cualquier plato para eliminar todos los ingredientes de Ã©l.</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/star.png" alt="ComodÃ­n"></span> <p><strong>ComodÃ­n:</strong> Este artÃ­culo especial se puede apilar sobre cualquier cosa y cuenta como cualquier ingrediente que necesites.</p></div>
                 <div class="flex items-start gap-4"> <span class="w-8 h-8 flex-shrink-0"><img src="/img/corbys.png" alt="corbys"></span> <p><strong>Corbys:</strong> Gana corbys completando pedidos. Â¡Ãšsalas para desbloquear mÃ¡s platos!</p></div>
             </div>
             <div class="text-center mt-8">
                 <button id="how-to-play-close-button" class="btn btn-primary">Â¡Entendido!</button>
             </div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        const firebaseConfig = {
            apiKey: "AIzaSyCItweZXDBw6X2E1qDVNi0HBHDq-Jo2yZE",
            authDomain: "dish-dash-1ac95.firebaseapp.com",
            projectId: "dish-dash-1ac95",
            storageBucket: "dish-dash-1ac95.firebasestorage.app",
            messagingSenderId: "901088920476",
            appId: "1:901088920476:web:f54338cf449ee7ee99be59",
            measurementId: "G-ZYQ277D98F"
          };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const userGreetingEl = document.getElementById('user-greeting');
        const startGameButton = document.getElementById('start-game-button');
        const resetProgressButton = document.getElementById('reset-progress-button');
        let currentUserId = null;
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUserId = user.uid;
                userGreetingEl.textContent = `Â¡Bienvenido de nuevo, ${user.displayName.split(' ')[0]}!`;
                loginButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
                startGameButton.classList.remove('hidden');
                resetProgressButton.classList.remove('hidden');
                window.dishDashGame.loadProgress(); 
            } else {
                currentUserId = null;
                userGreetingEl.textContent = `Â¡Por favor, inicia sesiÃ³n para empezar a cocinar!`;
                loginButton.classList.remove('hidden');
                logoutButton.classList.add('hidden');
                startGameButton.classList.add('hidden');
                resetProgressButton.classList.add('hidden');
                window.dishDashGame.resetGameStateToDefault(); 
            }
        });
        const signInWithGoogle = async () => {
            try { await signInWithPopup(auth, provider); } catch (error) { console.error("Error durante el inicio de sesiÃ³n:", error); alert(`Error: ${error.message}`); }
        };
        const logout = async () => {
            try { await signOut(auth); window.location.reload(); } catch (error) { console.error("Error al cerrar sesiÃ³n:", error); }
        };
        async function loadProgressFromFirestore() {
            if (!currentUserId) return null;
            const docRef = doc(db, "userProgress", currentUserId);
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) { return docSnap.data(); } else { return null; }
        }
        async function saveProgressToFirestore(progressData) {
            if (!currentUserId) return;
            try { await setDoc(doc(db, "userProgress", currentUserId), progressData); } catch (e) { console.error("Error guardando documento: ", e); }
        }
        async function resetProgressInFirestore() {
            if (!currentUserId) return;
            try { await deleteDoc(doc(db, "userProgress", currentUserId)); } catch (e) { console.error("Error reiniciando el progreso: ", e); }
        }
        loginButton.addEventListener('click', signInWithGoogle);
        logoutButton.addEventListener('click', logout);
        window.firebaseIntegration = { loadProgressFromFirestore, saveProgressToFirestore, resetProgressInFirestore };
    </script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CONSTANTS AND STATE ---
        const MAX_INGREDIENTS_PER_PLATE = 30;
        const DEAL_LIMIT = 15;
        const TOTAL_LEVELS = 100;

        const allPossibleIngredients = [
            { id: 'strawberry', name: 'Fresa', emoji: 'ðŸ“', imageUrl: '/img/strawberry.png' },
            { id: 'banana', name: 'Banana', emoji: 'ðŸŒ', imageUrl: '/img/banana.png' },
            { id: 'grapes', name: 'Uvas', emoji: 'ðŸ‡', imageUrl: '/img/grape.png' },
            { id: 'carrot', name: 'Zanahoria', emoji: 'ðŸ¥•', imageUrl: '/img/carrot.png' },
            { id: 'broccoli', name: 'BrÃ³coli', emoji: 'ðŸ¥¦', imageUrl: '/img/broccoli.png' },
            { id: 'mushroom', name: 'ChampiÃ±Ã³n', emoji: 'ðŸ„', imageUrl: '/img/mushroom.png' },
            { id: 'tomato', name: 'Tomate', emoji: 'ðŸ…', imageUrl: '/img/tomato.png' },
            { id: 'avocado', name: 'Aguacate', emoji: 'ðŸ¥‘', imageUrl: '/img/avocado.png' },
            { id: 'eggplant', name: 'Berenjena', emoji: 'ðŸ†', imageUrl: '/img/eggplant.png' },
            { id: 'chili', name: 'Chile', emoji: 'ðŸŒ¶ï¸', imageUrl: '/img/pepper.png' }
        ];

        const specialItems = {
            wildcard: { id: 'wildcard', name: 'ComodÃ­n', emoji: 'ðŸŒŸ', imageUrl: '/img/star.png' },
            bomb: { id: 'bomb', name: 'Bomba', emoji: 'ðŸ’£', imageUrl: '/img/bomb.png' },
            golden: { id: 'golden', name: 'Dorado', emoji: 'ðŸ†', imageUrl: '/img/golden.png' }
        };

        const allIngredientData = {
            ...Object.fromEntries(allPossibleIngredients.map(item => [item.id, item])),
            ...Object.fromEntries(Object.values(specialItems).map(item => [item.id, item]))
        };
        
        const initialGameState = {
            highestLevelUnlocked: 0, currentLevelIndex: 0, ordersCompletedInLevel: 0,
            totalOrdersInLevel: 0, levelOrderQueue: [],
            stars: 0, platesUnlocked: 3, currentRecipe: null, plates: [],
            deck: [], selectedStack: null, isAnimating: false,
            unlockedIngredients: [], trashUsesLeft: 0,
        };
        let gameState = { ...initialGameState };
        
        // --- UI ELEMENTS ---
        const homeScreenEl = document.getElementById('home-screen');
        const gameUiEl = document.getElementById('game-ui');
        const levelMapScreenEl = document.getElementById('level-map-screen');
        const levelMapContainer = document.getElementById('level-map-container');
        const startGameButton = document.getElementById('start-game-button');
        const resetProgressButton = document.getElementById('reset-progress-button');
        const backToHomeButton = document.getElementById('back-to-home-button');
        const backToMapButton = document.getElementById('back-to-map-button');
        const dealButton = document.getElementById('deal-button');
        const deckCountEl = document.getElementById('deck-count');
        const recipeNameEl = document.getElementById('recipe-name');
        const recipeIngredientsEl = document.getElementById('recipe-ingredients');
        const levelDisplayEl = document.getElementById('level-display').querySelector('span');
        const orderProgressEl = document.getElementById('order-progress').querySelector('span');
        const starCounterEl = document.getElementById('star-counter').querySelector('span');
        const orderInfoEl = document.getElementById('order-info');
        const animationLayer = document.getElementById('animation-layer');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const messageButtonsContainer = document.getElementById('message-buttons');
        const timerContainer = document.getElementById('timer-container');
        const timerBar = document.getElementById('timer-bar');
        const vipBadge = document.getElementById('vip-badge');
        const customerTypeBadge = document.getElementById('customer-type-badge');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const howToPlayModal = document.getElementById('how-to-play-modal');
        const howToPlayContent = document.getElementById('how-to-play-content');
        const howToPlayCloseButton = document.getElementById('how-to-play-close-button');
        const howToPlayCloseButtonX = document.getElementById('how-to-play-close-button-x');
        const trashCanEl = document.getElementById('trash-can');
        const trashCounterEl = document.getElementById('trash-counter');
        const cozyGradientMap = {
            'strawberry': 'bg-gradient-to-br from-pink-300 to-red-400', 'banana': 'bg-gradient-to-br from-yellow-200 to-yellow-300', 'grapes': 'bg-gradient-to-br from-purple-300 to-indigo-400', 'carrot': 'bg-gradient-to-br from-orange-200 to-amber-400', 'broccoli': 'bg-gradient-to-br from-green-300 to-emerald-400', 'mushroom': 'bg-gradient-to-br from-stone-300 to-stone-400', 'tomato': 'bg-gradient-to-br from-red-400 to-red-500', 'avocado': 'bg-gradient-to-br from-lime-300 to-green-500', 'eggplant': 'bg-gradient-to-br from-purple-400 to-violet-600', 'chili': 'bg-gradient-to-br from-red-500 to-orange-600',
            [specialItems.wildcard.id]: 'bg-gradient-to-br from-yellow-300 via-amber-300 to-orange-400',
            [specialItems.bomb.id]: 'bg-gradient-to-br from-gray-600 to-black',
            [specialItems.golden.id]: 'bg-gradient-to-br from-yellow-300 to-amber-500'
        };
        let timerInterval = null;

        // --- CORE DATA & STATE FUNCTIONS ---
        async function loadProgress() {
            if (!window.firebaseIntegration) { setTimeout(loadProgress, 100); return; }
            const savedState = await window.firebaseIntegration.loadProgressFromFirestore();
            Object.assign(gameState, initialGameState, savedState || {});
            if (!savedState) await saveProgress();
            renderLevelMap();
        }
        async function saveProgress() {
            if (!window.firebaseIntegration) return;
            const progressToSave = { highestLevelUnlocked: gameState.highestLevelUnlocked, currentLevelIndex: gameState.currentLevelIndex, stars: gameState.stars, platesUnlocked: gameState.platesUnlocked };
            await window.firebaseIntegration.saveProgressToFirestore(progressToSave);
        }
        function resetGameStateToDefault() { Object.assign(gameState, initialGameState); renderLevelMap(); }
        function resetProgress() {
            showMessage("Reiniciar Progreso", "Â¿EstÃ¡s seguro de que quieres empezar de nuevo? Todas tus estrellas y niveles desbloqueados se perderÃ¡n para siempre.", [
                {text: "Cancelar", primary: false},
                {text: "SÃ­, Reiniciar", primary: true, action: async () => {
                    if (window.firebaseIntegration) await window.firebaseIntegration.resetProgressInFirestore();
                    resetGameStateToDefault(); renderLevelMap();
                }}
            ]);
        }
        
        // --- GAME FLOW FUNCTIONS ---
        // LOGIC UPDATED
        function handleOrderCompletion() {
            if(timerInterval) clearInterval(timerInterval);
            gameState.levelOrderQueue.shift(); // Consume the completed recipe
            gameState.ordersCompletedInLevel++;
            
            if(gameState.levelOrderQueue.length === 0) {
                 handleLevelComplete(); 
            } else { 
                serveNewOrder(); 
            }
        }

        async function handleLevelComplete() {
            if (gameState.currentLevelIndex >= gameState.highestLevelUnlocked) {
                gameState.highestLevelUnlocked = gameState.currentLevelIndex + 1;
            }
            gameState.currentRecipe = null;
            await saveProgress();
            const onConfirm = () => {
                if (gameState.currentLevelIndex >= TOTAL_LEVELS - 1) {
                    handleGameWon();
                } else {
                    startGame(gameState.currentLevelIndex + 1);
                }
            };
            showMessage("Â¡Nivel Completado!", `Â¡Has completado todos los pedidos! Has desbloqueado la siguiente receta.`, [{ text: "PrÃ³ximo Nivel", action: onConfirm, primary: true }]);
        }
        async function handleUnlockPlateClick() {
            if (gameState.platesUnlocked >= 11) return;
            const cost = 1150 + (gameState.platesUnlocked - 3) * 500;
            if (gameState.stars >= cost) {
                showMessage("Desbloquear Plato", `Â¿Gastar ${cost} â­ para desbloquear este plato?`, [
                    { text: "Ahora no", primary: false },
                    { text: "Desbloquear", primary: true, action: async () => {
                        gameState.stars -= cost; gameState.platesUnlocked++; gameState.plates.push([]);
                        await saveProgress(); renderGame();
                    }}
                ]);
            } else showMessage("Â¡Estrellas Insuficientes!", `Necesitas ${cost} â­ para desbloquear este plato.`, [{ text: 'OK', primary: true }]);
        }
        
        // --- UI & HELPER FUNCTIONS ---
        function showMessage(title, text, buttonsConfig) {
            messageTitle.textContent = title; messageText.innerHTML = text; messageButtonsContainer.innerHTML = ''; 
            if (!buttonsConfig || buttonsConfig.length === 0) {
                const okButton = document.createElement('button'); okButton.textContent = 'Â¡Entendido!'; okButton.className = 'btn btn-primary'; okButton.onclick = closeMessage; messageButtonsContainer.appendChild(okButton);
            } else {
                 buttonsConfig.forEach(config => {
                     const button = document.createElement('button'); button.textContent = config.text; button.className = `btn ${config.primary ? 'btn-primary' : 'btn-secondary'}`;
                     button.onclick = () => { if(!config.noClose) closeMessage(); if (config.action) config.action(); };
                     messageButtonsContainer.appendChild(button);
                 });
            }
            messageBox.classList.remove('opacity-0', 'pointer-events-none'); messageBox.querySelector('div').classList.remove('scale-95');
        }
        function closeMessage() {
            messageBox.classList.add('opacity-0'); setTimeout(() => messageBox.classList.add('pointer-events-none'), 300); messageBox.querySelector('div').classList.add('scale-95');
        }
        function showScreen(screenEl) {
            homeScreenEl.classList.add('hidden');
            gameUiEl.classList.add('hidden');
            levelMapScreenEl.classList.add('hidden');
            screenEl.classList.remove('hidden');
        }
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
        
        // --- RENDER & GAME SETUP FUNCTIONS ---
        function renderLevelMap() {
            levelMapContainer.innerHTML = '';
            for (let i = 0; i < TOTAL_LEVELS; i++) {
                const isUnlocked = i <= gameState.highestLevelUnlocked;
                const nodeContainer = document.createElement('div'); nodeContainer.className = 'level-node'; 
                const button = document.createElement('button'); button.disabled = !isUnlocked; button.className = `level-node-button ${isUnlocked ? '' : 'locked'}`; button.onclick = () => startGame(i);
                const content = document.createElement('div'); content.className = 'level-content';
                if (isUnlocked) content.innerHTML = `<div class="level-number">${i + 1}</div><div class="level-text-label">Receta</div>`;
                else content.innerHTML = `<div class="lock-icon-map"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zM9 7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9V7z"></path></svg></div>`;
                button.appendChild(content); nodeContainer.appendChild(button); levelMapContainer.appendChild(nodeContainer);
            }
        }
        function showLevelMap() { renderLevelMap(); showScreen(levelMapScreenEl); }
        function generateLevelData(levelIndex) {
            const levelNumber = levelIndex + 1; const ordersToComplete = Math.min(10, 2 + Math.floor(levelIndex / 3));
            const platesActive = Math.min(11, 3 + Math.floor(levelIndex / 2)); const unlocks = (levelIndex < allPossibleIngredients.length) ? 1 : 0;
            const deckSize = 80 + levelIndex * 15; const ingredientCount = Math.min(Math.floor(2 + levelIndex / 3), allPossibleIngredients.length);
            return { id: levelNumber, ordersToComplete, platesActive, deckSize, unlocks, ingredientCount };
        }
        // LOGIC UPDATED
        function startGame(levelIndex) {
            showScreen(gameUiEl); 
            gameState.currentLevelIndex = levelIndex;
            gameState.ordersCompletedInLevel = 0;
            gameState.levelOrderQueue = [];
            gameState.plates = Array.from({ length: gameState.platesUnlocked }, () => []); 
            gameState.trashUsesLeft = 3 + Math.floor(levelIndex / 5);

            const currentLevel = generateLevelData(levelIndex);
            gameState.totalOrdersInLevel = currentLevel.ordersToComplete;
            
            let unlockedCount = 2; 
            for(let i = 0; i < levelIndex; i++) {
                unlockedCount += generateLevelData(i).unlocks || 0;
            }
            gameState.unlockedIngredients = allPossibleIngredients.slice(0, Math.min(unlockedCount, allPossibleIngredients.length)).map(ing => ing.id);
            
            // Generate all recipes for the level in advance
            for (let i = 0; i < currentLevel.ordersToComplete; i++) {
                gameState.levelOrderQueue.push(generateRecipeForLevel(currentLevel, gameState.unlockedIngredients));
            }
            
            serveNewOrder();
        }
        function createDeck(level, ingredientPool, recipe, extraIngredients = []) {
            let newDeck = [...extraIngredients];
            if (recipe && recipe.ingredients) {
                for (const [ingredientId, count] of Object.entries(recipe.ingredients)) {
                    for (let i = 0; i < count; i++) {
                        const isGolden = Math.random() < 0.1; 
                        newDeck.push({ type: isGolden ? specialItems.golden.id : ingredientId, originalType: ingredientId, id: `req-${ingredientId}-${i}-${Math.random()}` });
                    }
                }
            }
            const potentialDistractors = allPossibleIngredients.map(i => i.id).filter(id => !ingredientPool.includes(id));
            if (potentialDistractors.length > 0) { const distractor = potentialDistractors[0]; for (let i = 0; i < 5; i++) newDeck.push({ type: distractor, id: `distractor-${distractor}-${i}-${Math.random()}`}); }
            const specialIngredientCount = Math.floor(level.deckSize / 20);
            for (let i = 0; i < specialIngredientCount; i++) { 
                const type = Math.random() < 0.6 ? specialItems.bomb.id : specialItems.wildcard.id; 
                newDeck.push({ type, id: `special-${type}-${i}-${Math.random()}` }); 
            }
            const fillerCount = level.deckSize - newDeck.length;
            for (let i = 0; i < fillerCount; i++) { const randomType = ingredientPool[Math.floor(Math.random() * ingredientPool.length)]; newDeck.push({ type: randomType, id: `fill-${i}-${Math.random()}` }); }
            shuffleArray(newDeck); return newDeck;
        }
        function generateRandomRecipeName() {
            const adjectives = ["Acogedor", "CÃ¡lido", "Dorado", "RÃºstico", "HogareÃ±o", "Brillante", "Crepuscular", "Campestre"];
            const nouns = ["Deleite", "Guiso", "Manjar", "FestÃ­n", "Pastel", "NÃ©ctar", "Bocado", "Breveje"];
            return `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
        }
        function generateRecipeForLevel(level, unlockedIngredients) {
            const recipeIngredients = {}; const shuffledPool = [...unlockedIngredients]; shuffleArray(shuffledPool);
            const ingredientCountForRecipe = Math.min(shuffledPool.length, 3); const ingredientsForRecipe = shuffledPool.slice(0, ingredientCountForRecipe);
            ingredientsForRecipe.forEach(ingredientId => { recipeIngredients[ingredientId] = 10; });
            return { name: generateRandomRecipeName(), ingredients: recipeIngredients };
        }
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval); const recipe = gameState.currentRecipe; if (!recipe || !recipe.isVIP) return;
            timerInterval = setInterval(() => {
                recipe.timeLeft--; const percentage = (recipe.timeLeft / recipe.timerDuration) * 100; timerBar.style.width = `${percentage}%`;
                if (recipe.timeLeft <= 0) { clearInterval(timerInterval); showMessage("Â¡Se acabÃ³ el tiempo!", "El cliente VIP se ha ido. Â¡IntÃ©ntalo de nuevo!", [{ text: "OK", primary: true, action: () => {
                    gameState.levelOrderQueue.shift(); // Skip the failed VIP order
                    if (gameState.levelOrderQueue.length === 0) {
                        handleLevelComplete();
                    } else {
                        serveNewOrder();
                    }
                } }]); }
            }, 1000);
        }
        // LOGIC UPDATED
        function serveNewOrder() {
            if (timerInterval) clearInterval(timerInterval);

            if (gameState.levelOrderQueue.length === 0) {
                // This case should be handled by handleOrderCompletion, but as a safeguard:
                console.log("Attempted to serve new order, but queue is empty. Finishing level.");
                handleLevelComplete();
                return;
            }
            
            gameState.currentRecipe = gameState.levelOrderQueue[0]; // Peek at the next recipe

            const currentLevel = generateLevelData(gameState.currentLevelIndex);
            
            // Set up special customer types
            gameState.currentRecipe.isVIP = false;
            gameState.currentRecipe.customerType = 'normal';
            const randomCustomer = Math.random();
            if (gameState.currentLevelIndex >= 5 && randomCustomer < 0.3) {
                gameState.currentRecipe.customerType = 'picky';
                const order = [];
                for(const [ing, count] of Object.entries(gameState.currentRecipe.ingredients)) { 
                    for(let i=0; i < count; i++) order.push(ing);
                }
                shuffleArray(order); 
                gameState.currentRecipe.ingredientOrder = order;
            } else if (gameState.currentLevelIndex >= 2 && randomCustomer < 0.5) {
                gameState.currentRecipe.isVIP = true; 
                gameState.currentRecipe.timerDuration = 60; 
                gameState.currentRecipe.timeLeft = 60; 
                startTimer();
            }
            
            gameState.currentRecipe.needed = { ...gameState.currentRecipe.ingredients };
            gameState.deck = createDeck(currentLevel, gameState.unlockedIngredients, gameState.currentRecipe);
            gameState.selectedStack = null; 
            renderGame();
        }
       
        // LOGIC UPDATED
        function dealRow() {
            if (gameState.isAnimating || gameState.deck.length === 0) return;
            if (gameState.selectedStack) gameState.selectedStack = null;
            
            const deals = [];
            const availablePlates = [];
            for (let i = 0; i < gameState.platesUnlocked; i++) {
                if (gameState.plates[i].length < DEAL_LIMIT) {
                    availablePlates.push(i);
                }
            }

            if (availablePlates.length === 0) {
                dealButton.classList.add('shake');
                setTimeout(() => dealButton.classList.remove('shake'), 500);
                return;
            }

            // --- STRATEGIC DEAL LOGIC ---
            // 1. Identify types of ingredients
            const neededNowTypes = Object.keys(gameState.currentRecipe.needed || {}).filter(type => gameState.currentRecipe.needed[type] > 0);
            
            let neededSoonTypes = [];
            if (gameState.levelOrderQueue.length > 1) { // Check if there is a "next" recipe
                const nextRecipe = gameState.levelOrderQueue[1];
                if (nextRecipe) {
                    neededSoonTypes = Object.keys(nextRecipe.ingredients || {}).filter(type => !neededNowTypes.includes(type));
                }
            }

            // 2. Partition the deck
            const neededNowDeck = [];
            const neededSoonDeck = [];
            const otherDeck = [];

            gameState.deck.forEach(ing => {
                const type = ing.originalType || ing.type;
                if (neededNowTypes.includes(type)) {
                    neededNowDeck.push(ing);
                } else if (neededSoonTypes.includes(type)) {
                    neededSoonDeck.push(ing);
                } else {
                    otherDeck.push(ing);
                }
            });

            shuffleArray(neededNowDeck);
            shuffleArray(neededSoonDeck);
            shuffleArray(otherDeck);

            // 3. Deal based on probability
            availablePlates.forEach(plateIndex => {
                let ingredientToDeal = null;
                const chance = Math.random();

                // 70% chance for a currently needed ingredient
                if (chance < 0.7) { 
                    if (neededNowDeck.length > 0) ingredientToDeal = neededNowDeck.pop();
                    else if (neededSoonDeck.length > 0) ingredientToDeal = neededSoonDeck.pop();
                    else if (otherDeck.length > 0) ingredientToDeal = otherDeck.pop();
                } 
                // 20% chance for a soon-to-be-needed ingredient (70% -> 90%)
                else if (chance < 0.9) { 
                    if (neededSoonDeck.length > 0) ingredientToDeal = neededSoonDeck.pop();
                    else if (neededNowDeck.length > 0) ingredientToDeal = neededNowDeck.pop();
                    else if (otherDeck.length > 0) ingredientToDeal = otherDeck.pop();
                } 
                // 10% chance for any other ingredient
                else { 
                    if (otherDeck.length > 0) ingredientToDeal = otherDeck.pop();
                    else if (neededSoonDeck.length > 0) ingredientToDeal = neededSoonDeck.pop();
                    else if (neededNowDeck.length > 0) ingredientToDeal = neededNowDeck.pop();
                }
                
                if (ingredientToDeal) {
                    deals.push({ toPlateIndex: plateIndex, ingredient: ingredientToDeal });
                }
            });

            // 4. Rebuild and animate
            gameState.deck = [...neededNowDeck, ...neededSoonDeck, ...otherDeck];
            shuffleArray(gameState.deck);

            if (deals.length > 0) {
                animateDeal(deals);
            } else {
                renderGame();
            }
        }
        
        // --- CORE GAME LOGIC & RENDERING ---
        function renderGame() {
            const recipe = gameState.currentRecipe; if (!recipe) return;
            
            levelDisplayEl.textContent = `Nivel: ${gameState.currentLevelIndex + 1}`;
            orderProgressEl.textContent = `Pedidos: ${gameState.ordersCompletedInLevel + 1}/${gameState.totalOrdersInLevel}`;
            starCounterEl.textContent = gameState.stars; recipeNameEl.textContent = recipe.name;
            vipBadge.classList.toggle('hidden', !recipe.isVIP);
            customerTypeBadge.classList.toggle('hidden', recipe.customerType !== 'picky');
            if(recipe.customerType === 'picky') customerTypeBadge.textContent = 'Â¡En Orden!';
            timerContainer.classList.toggle('hidden', !recipe.isVIP);
            if (recipe.isVIP) { const percentage = (recipe.timeLeft / recipe.timerDuration) * 100; timerBar.style.width = `${percentage}%`; }
            recipeIngredientsEl.innerHTML = '';
            
            if(recipe.customerType === 'picky') {
                recipe.ingredientOrder.forEach((ingredientId, index) => {
                    const masterData = allIngredientData[ingredientId];
                    if (!masterData) return;
                    const span = document.createElement('span');
                    span.className = 'recipe-ingredient-ordered';
                    if (index === 0) span.classList.add('next-in-order', 'font-bold', 'text-accent', 'scale-125');
                    span.innerHTML = `<img src="${masterData.imageUrl}" class="recipe-img" alt="${masterData.name}">`;
                    recipeIngredientsEl.appendChild(span);
                });
            } else {
                recipeIngredientsEl.innerHTML = Object.entries(recipe.ingredients)
                    .map(([ingredientId, targetCount]) => {
                        const masterData = allIngredientData[ingredientId];
                        const needed = Math.max(0, recipe.needed[ingredientId]);
                        const isComplete = needed <= 0;
                        const displayCount = isComplete ? 0 : targetCount;
                        const imgTag = masterData ? `<img src="${masterData.imageUrl}" class="recipe-img" alt="${masterData.name}">` : `<span>${ingredientId}</span>`;
                        return `<span class="recipe-ingredient inline-flex items-center ${isComplete ? 'line-through text-stone-400 opacity-60' : ''}">${imgTag} x${displayCount}</span>`;
                    }).join(' ');
            }

            document.querySelectorAll('.plate-wrapper').forEach((wrapper, index) => {
                const plateArea = wrapper.querySelector('.plate-area'); const isActive = index < gameState.platesUnlocked;
                plateArea.classList.remove('potential-target', 'bomb-target', 'ring-2', 'ring-red-500');
                if (isActive) {
                    plateArea.classList.remove('locked'); const plate = gameState.plates[index]; plateArea.innerHTML = '';
                    wrapper.onclick = () => handlePlateClick(index);
                    if (plate) {
                        plate.forEach((ingredient, ingredientIndex) => {
                            const ingredientEl = createAnimatedClone(ingredient); let transformValue = `translateX(-50%) translateZ(${ingredientIndex * 5}px)`;
                            if (gameState.selectedStack?.fromPlate === index && gameState.selectedStack.stack.some(s => s.id === ingredient.id)) {
                                 transformValue += ' translateZ(25px) scale(1.05)'; 
                                 if(ingredientIndex === plate.length - 1) {
                                     const counter = document.createElement('div'); counter.className = 'stack-counter'; counter.textContent = gameState.selectedStack.stack.length; ingredientEl.appendChild(counter);
                                 }
                            }
                            ingredientEl.style.transform = transformValue; plateArea.appendChild(ingredientEl);
                        });
                    }
                    if (gameState.selectedStack?.stack?.length > 0) {
                        const stackType = gameState.selectedStack.stack[0].type;
                        if(stackType === specialItems.bomb.id) {
                            plateArea.classList.add('bomb-target', 'ring-2', 'ring-red-500');
                        }
                        else if (canMoveStackTo(gameState.selectedStack.stack, plate)) {
                            plateArea.classList.add('potential-target'); 
                        }
                    }
                } else {
                    plateArea.classList.add('locked'); plateArea.innerHTML = `<div class="lock-icon"><span><img src="/img/padlock.png" alt="Candado" style="width: 100%; height: 100%;"></span></div>`;
                    wrapper.onclick = () => handleUnlockPlateClick(); 
                }
            });
            orderInfoEl.classList.toggle('ring-2', isStackDeliverable(gameState.selectedStack)); orderInfoEl.classList.toggle('ring-primary', isStackDeliverable(gameState.selectedStack));
            trashCanEl.disabled = !gameState.selectedStack || gameState.trashUsesLeft <= 0 || (gameState.selectedStack && gameState.selectedStack.stack[0].type === specialItems.bomb.id);
            trashCounterEl.textContent = gameState.trashUsesLeft;
            const allPlatesFull = gameState.plates.every(p => p.length >= MAX_INGREDIENTS_PER_PLATE);
            dealButton.disabled = allPlatesFull || isOrderComplete(); deckCountEl.textContent = gameState.deck.length;
        }

        function handlePlateClick(plateIndex) {
            if (gameState.isAnimating) return;
            const clickedPlate = gameState.plates[plateIndex];

            if (!gameState.selectedStack) {
                if (clickedPlate.length === 0) return;
                
                const topIngredient = clickedPlate[clickedPlate.length - 1];
                const movableStack = [];
                const typeToMatch = topIngredient.type === specialItems.golden.id ? topIngredient.originalType : topIngredient.type;

                for (let i = clickedPlate.length - 1; i >= 0; i--) {
                    const currentIngredient = clickedPlate[i];
                    const currentTypeForMatching = currentIngredient.type === specialItems.golden.id ? currentIngredient.originalType : currentIngredient.type;
                    
                    if (currentTypeForMatching === typeToMatch) {
                        movableStack.unshift(currentIngredient);
                    } else {
                        break;
                    }
                }
                gameState.selectedStack = { fromPlate: plateIndex, stack: movableStack };

            } else {
                const { fromPlate, stack } = gameState.selectedStack;
                
                if (stack[0].type === specialItems.bomb.id) {
                    clearPlateWithBomb(plateIndex, fromPlate);
                    return;
                }
                
                if (fromPlate === plateIndex) {
                    gameState.selectedStack = null;
                } else if (canMoveStackTo(stack, clickedPlate)) {
                    moveStack(plateIndex);
                } else {
                    const plateWrapperEl = document.getElementById(`plate-${plateIndex}`).parentElement;
                    plateWrapperEl.classList.add('shake');
                    setTimeout(() => plateWrapperEl.classList.remove('shake'), 500);
                    gameState.selectedStack = null;
                }
            }
            renderGame();
        }
        
        function canMoveStackTo(stack, destinationPlate) {
            if (!stack || stack.length === 0 || destinationPlate.length + stack.length > MAX_INGREDIENTS_PER_PLATE) return false;
            const stackType = stack[0].type;
            if ([specialItems.bomb.id, 'ðŸ¤¢'].includes(stackType)) return false; 
        
            if (destinationPlate.length === 0) return true;
        
            const destTop = destinationPlate[destinationPlate.length - 1];
            const destType = destTop.type;
            if ([specialItems.bomb.id, 'ðŸ¤¢'].includes(destType)) return false;
        
            if (stackType === specialItems.wildcard.id) return true; 
        
            const stackOriginalType = stack[0].originalType || stackType;
            const destOriginalType = destTop.originalType || destType;
            
            return destType === specialItems.wildcard.id || stackOriginalType === destOriginalType;
        }
        
        function createAnimatedClone(ingredientData) {
            const clone = document.createElement('div');
            clone.className = 'ingredient';

            const typeId = ingredientData.type;
            const originalTypeId = ingredientData.originalType || typeId;
            
            const gradientClasses = (cozyGradientMap[typeId === specialItems.golden.id ? originalTypeId : typeId] || 'bg-stone-200').split(' ');
            clone.classList.add(...gradientClasses);

            if (typeId === specialItems.golden.id) {
                clone.classList.add('golden');
            }

            const inner = document.createElement('div');
            inner.className = 'ingredient-inner';

            const masterData = allIngredientData[typeId === specialItems.golden.id ? originalTypeId : typeId];

            if (masterData && masterData.imageUrl) {
                const img = document.createElement('img');
                img.src = masterData.imageUrl;
                img.alt = masterData.name;
                inner.appendChild(img);
            } else {
                inner.textContent = masterData ? masterData.emoji : '?';
                inner.style.fontSize = '2.5rem';
            }
            
            clone.appendChild(inner);
            return clone;
        }

        function handleRecipeClick() {
            if (gameState.isAnimating || !isStackDeliverable(gameState.selectedStack)) {
                if (gameState.selectedStack) {
                    orderInfoEl.classList.add('shake');
                    setTimeout(() => orderInfoEl.classList.remove('shake'), 500);
                    gameState.selectedStack = null;
                    renderGame();
                }
                return;
            }
            const { fromPlate, stack } = gameState.selectedStack;
            const type = stack[0].type;
            const originalType = stack[0].originalType || type;
            gameState.isAnimating = true;

            if (gameState.currentRecipe.customerType === 'picky') {
                gameState.currentRecipe.ingredientOrder.splice(0, stack.length);
            } else {
                if (type === specialItems.wildcard.id) {
                    const neededIngredientId = Object.keys(gameState.currentRecipe.ingredients).find(ingId =>
                        gameState.currentRecipe.needed[ingId] > 0 && stack.length >= gameState.currentRecipe.ingredients[ingId]
                    );
                    if (neededIngredientId) {
                        gameState.currentRecipe.needed[neededIngredientId] = 0;
                    }
                } else {
                    if (gameState.currentRecipe.needed[originalType] > 0) {
                         gameState.currentRecipe.needed[originalType] = 0;
                    }
                }
            }

            let starsEarned = type === specialItems.golden.id ? 50 : 15;
            if (gameState.currentRecipe.isVIP) starsEarned += 20;
            if (gameState.currentRecipe.customerType === 'picky') starsEarned += 10;
            gameState.stars += starsEarned;
            gameState.selectedStack = null;
            const deliveredIngredients = gameState.plates[fromPlate].splice(-stack.length);
            renderGame(); 

            const orderRect = orderInfoEl.getBoundingClientRect();
            const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect();
            deliveredIngredients.reverse().forEach((ingredientData, index) => {
                const clone = createAnimatedClone(ingredientData);
                Object.assign(clone.style, {
                    position: 'fixed',
                    zIndex: 1000 - index,
                    transition: 'all 0.4s cubic-bezier(0.5, -0.5, 0.75, 1.2)',
                    left: `${startRect.left + (startRect.width / 2) - 20}px`,
                    top: `${startRect.top + (startRect.height / 2) - 20}px`
                });
                animationLayer.appendChild(clone);
                setTimeout(() => Object.assign(clone.style, {
                    left: `${orderRect.left + (orderRect.width / 2) - 20}px`,
                    top: `${orderRect.top + (orderRect.height / 2) - 20}px`,
                    transform: 'scale(0.5)',
                    opacity: '0'
                }), index * 50);
                setTimeout(() => {
                    clone.remove();
                    if (index === deliveredIngredients.length - 1) {
                        gameState.isAnimating = false;
                        if (isOrderComplete()) {
                            handleOrderCompletion();
                        } else {
                            renderGame();
                        }
                    }
                }, index * 50 + 400);
            });
        }
        function moveStack(toPlateIndex) {
            if (gameState.isAnimating) return; const { fromPlate, stack } = gameState.selectedStack; gameState.isAnimating = true; gameState.selectedStack = null; gameState.plates[fromPlate].splice(-stack.length); renderGame();
            const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect(); const endRect = document.getElementById(`plate-${toPlateIndex}`).parentElement.getBoundingClientRect();
            stack.slice().reverse().forEach((ingredientData, index) => {
                const clone = createAnimatedClone(ingredientData); Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.4s cubic-bezier(0.5, -0.5, 0.75, 1.2)', left: `${startRect.left + (startRect.width / 2) - 20}px`, top: `${startRect.top + (startRect.height / 2) - 20}px`, transform: `translateZ(${ (gameState.plates[fromPlate].length + stack.length - index) * 5 }px) scale(1.1)` });
                animationLayer.appendChild(clone);
                setTimeout(() => Object.assign(clone.style, { left: `${endRect.left + (endRect.width / 2) - 20}px`, top: `${endRect.top + (endRect.height / 2) - 20}px`, transform: `translateZ(${ (gameState.plates[toPlateIndex].length + stack.length - index) * 5 }px) scale(1)` }), index * 40);
                setTimeout(() => { clone.remove(); if (index === stack.length - 1) { gameState.plates[toPlateIndex].push(...stack); gameState.isAnimating = false; renderGame(); } }, index * 40 + 400);
            });
        }
        function animateDeal(deals) {
            gameState.isAnimating = true; const dealButtonRect = dealButton.getBoundingClientRect();
            deals.forEach((deal, dealIndex) => {
                const { toPlateIndex, ingredient } = deal; const endRect = document.getElementById(`plate-${toPlateIndex}`).parentElement.getBoundingClientRect();
                const clone = createAnimatedClone(ingredient); Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - dealIndex, transition: 'all 0.4s cubic-bezier(0.3, 0, 0.4, 1), opacity 0.3s ease-in-out', left: `${dealButtonRect.left + (dealButtonRect.width / 2) - 20}px`, top: `${dealButtonRect.top + (dealButtonRect.height / 2) - 20}px`, transform: 'scale(0.8)', opacity: '0' });
                animationLayer.appendChild(clone);
                setTimeout(() => Object.assign(clone.style, { opacity: '1', left: `${endRect.left + (endRect.width / 2) - 20}px`, top: `${endRect.top + (endRect.height / 2) - 20}px`, transform: `scale(1) translateZ(${gameState.plates[toPlateIndex].length * 5}px)` }), 50 + dealIndex * 70); 
                setTimeout(() => { clone.remove(); if (dealIndex === deals.length - 1) { deals.forEach(d => { gameState.plates[d.toPlateIndex].push(d.ingredient); }); gameState.isAnimating = false; renderGame(); } }, 50 + dealIndex * 70 + 400);
            });
        }
        
        function isStackDeliverable(selectedStack) {
            if (!selectedStack) return false;
            const recipe = gameState.currentRecipe;
            if (!recipe) return false;
            const { stack } = selectedStack;
            if (stack.length === 0) return false;
            const type = stack[0].type;
            const originalType = stack[0].originalType || type;
            if (type === specialItems.bomb.id || type === 'ðŸ¤¢') return false;

            if (recipe.customerType === 'picky') {
                if (recipe.ingredientOrder.length === 0) return false;
                return type === specialItems.wildcard.id || originalType === recipe.ingredientOrder[0];
            }

            if (type === specialItems.wildcard.id) {
                return Object.entries(recipe.ingredients).some(([ingId, requiredCount]) => {
                    return recipe.needed[ingId] > 0 && stack.length >= requiredCount;
                });
            }
            
            const isStillNeeded = recipe.needed[originalType] > 0;
            const requiredAmount = recipe.ingredients[originalType];
            if (!isStillNeeded || !requiredAmount) {
                return false;
            }
            
            return stack.length >= requiredAmount;
        }

        function isOrderComplete() { if (!gameState.currentRecipe) return false; if(gameState.currentRecipe.customerType === 'picky') return gameState.currentRecipe.ingredientOrder.length === 0; return Object.values(gameState.currentRecipe.needed).every(count => count <= 0); }
        
        function handleGameWon() { showMessage("Â¡Felicitaciones!", "Â¡Has dominado la cocina!", [{ text: "Jugar de Nuevo", action: () => showScreen(homeScreenEl), primary: true }]); }
        function handleTrashClick() {
            if (gameState.isAnimating || !gameState.selectedStack || gameState.trashUsesLeft <= 0) return;
            const { fromPlate, stack } = gameState.selectedStack; if (stack[0].type === specialItems.bomb.id) return;
            gameState.trashUsesLeft--; gameState.isAnimating = true; gameState.selectedStack = null;
            const trashedIngredients = gameState.plates[fromPlate].splice(-stack.length); renderGame();
            const trashRect = trashCanEl.getBoundingClientRect(); const startRect = document.getElementById(`plate-${fromPlate}`).parentElement.getBoundingClientRect();
            trashedIngredients.reverse().forEach((ingredientData, index) => {
                const clone = createAnimatedClone(ingredientData); Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.5s cubic-bezier(0.5, -0.5, 0.2, 1)', left: `${startRect.left + (startRect.width / 2) - 20}px`, top: `${startRect.top + (startRect.height / 2) - 20}px` });
                animationLayer.appendChild(clone);
                setTimeout(() => Object.assign(clone.style, { left: `${trashRect.left + (trashRect.width / 2) - 15}px`, top: `${trashRect.top + (trashRect.height / 2) - 15}px`, transform: 'scale(0.3)', opacity: '0' }), index * 50);
                setTimeout(() => { clone.remove(); if(index === trashedIngredients.length - 1) { gameState.isAnimating = false; renderGame(); } }, index * 50 + 500);
            });
        }
        function clearPlateWithBomb(targetPlateIndex, bombPlateIndex) {
            if (gameState.isAnimating) return; gameState.isAnimating = true; gameState.selectedStack = null; gameState.plates[bombPlateIndex].pop();
            const ingredientsToClear = [...gameState.plates[targetPlateIndex]]; gameState.plates[targetPlateIndex] = []; renderGame();
            const targetRect = document.getElementById(`plate-${targetPlateIndex}`).parentElement.getBoundingClientRect();
            if(ingredientsToClear.length === 0) { gameState.isAnimating = false; renderGame(); return; }
            ingredientsToClear.forEach((ingredient, index) => {
                const clone = createAnimatedClone(ingredient); Object.assign(clone.style, { position: 'fixed', zIndex: 1000 - index, transition: 'all 0.5s ease-out', left: `${targetRect.left + (targetRect.width / 2) - 20}px`, top: `${targetRect.top + (targetRect.height / 2) - 20}px` });
                animationLayer.appendChild(clone);
                setTimeout(() => {
                    const angle = Math.random() * 2 * Math.PI, distance = 150 + Math.random() * 50;
                    clone.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0.5) rotate(${Math.random() * 360}deg)`;
                    clone.style.opacity = '0';
                }, 50);
                setTimeout(() => { clone.remove(); if(index === ingredientsToClear.length - 1) { gameState.isAnimating = false; renderGame(); } }, 550);
            });
        }
        
        // --- INITIALIZATION & LISTENERS ---
        startGameButton.addEventListener('click', showLevelMap);
        resetProgressButton.addEventListener('click', resetProgress);
        backToHomeButton.addEventListener('click', () => showScreen(homeScreenEl));
        backToMapButton.addEventListener('click', showLevelMap);
        dealButton.addEventListener('click', dealRow);
        orderInfoEl.addEventListener('click', handleRecipeClick);
        trashCanEl.addEventListener('click', handleTrashClick);
        const openHowToPlayModal = () => { howToPlayModal.classList.remove('opacity-0', 'pointer-events-none'); howToPlayContent.classList.remove('scale-95'); };
        const closeHowToPlayModal = () => { howToPlayModal.classList.add('opacity-0'); howToPlayContent.classList.add('scale-95'); setTimeout(() => howToPlayModal.classList.add('pointer-events-none'), 300); };
        howToPlayButton.addEventListener('click', openHowToPlayModal);
        howToPlayCloseButton.addEventListener('click', closeHowToPlayModal);
        howToPlayCloseButtonX.addEventListener('click', closeHowToPlayModal);
        howToPlayModal.addEventListener('click', (e) => e.target === howToPlayModal && closeHowToPlayModal());
        window.addEventListener('beforeunload', () => { if(window.firebaseIntegration) saveProgress(); });
        window.dishDashGame = { loadProgress, resetGameStateToDefault };
    });
    </script>
</body>
</html>
